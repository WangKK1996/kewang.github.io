<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[好难四儿啊]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%A5%BD%E9%9A%BE%E5%9B%9B%E5%84%BF%E5%95%8A%2F</url>
    <content type="text"><![CDATA[今儿在图书馆学习，学到了有关计算的前缀、中缀和后缀的内容。突然想到之前看过的一篇短篇科幻《好难四儿啊，那些（看不懂的字*n)》 这篇文章说的是思维定式。今天看到前缀后缀很明显会比中缀简单很多（因为不需要加上括号之类的辅助就可以把一个表达式写得清清楚楚），然而我读起来实在是吃力。可能这就是思维定式吧。 这是我鲜有意识到思维局限的情况，人往往都是愚蠢而不自知的。细思恐极。]]></content>
      <categories>
        <category>杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构Pyhton（四）-栈和队列.md]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-md%2F</url>
    <content type="text"><![CDATA[在常用的数据结构中，有一批结构被称为“容器”。一个容器结构里总包含一组其他类型的数据对象，称其为元素。 除了线性表意外，还有两种最常用的容器，称为栈（stack)和队列(queue)，他们都是使用最广泛的数据结构。 本章重点 概述 栈：保证元素后进先出（Last In First Out,LIFO)，简称LIFO结构。 队列：保证元素先进先出（First In First Out) 栈（stack) 栈结构的顺序表实现 12345678910111213141516171819class SStack(): def __init__(self): # 用list对象_elem存储栈中元素 self._elems = [] # 所有栈操作都映射到list中 def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow("in SStack.top()") return self.elem[-1] # 后进先出，得到最后一个元素 def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow("in SStack.pop()") return self._elems.pop() # 以列表形式弹出 栈的链接表实现 以下是基于LNode链接表实现的。有关于LNode的定义见这篇文章 123456789101112131415161718192021class LStack(): # 基于链接表技术实现的栈类，用LNode作为结点 def __init__(self): self._top = None def is_empty(self): return self._top is None def top(self): if self._top is None: raise StackUnderflow("in LStack.top()") return self._top.elem def push(self, elem): self._top = LNode(elem, self._top) def pop(self): if self._top is None: raise StackUnderflow("in LStack pop()") p = self._top self._top = p.next return p.elem 栈的应用 算法或者程序里的辅助存储结构 后进先出的性质，保证特定的存取顺序。 颠倒一组的顺序 12345678#假设list1里存储这要颠倒的列表list1 = [1, 2, 3, 4, 5]st1 = SStack()for x in list1: st1.push(x)list2 = []while not st1.is_empty(): list2.append(st1.pop()) 括号匹配问题 逻辑： 检查文本，找出括号 找到的开括号，压进栈中 找到的闭括号和最近找到的开括号进行匹配； 成功则继续，不匹配则以失败结束。 代码实现： 1234567891011121314151617181920212223242526272829303132def check_parens(text): """ 括号匹配检查函数，text是被检查的正文串 """ parens = "()[]&#123;&#125;" open_parens = "([&#123;" opposite = &#123;")":"(", "]": "[", "&#125;": "&#123;"&#125; # 表示配对关系的字典 def parentheses(text): """括号生成器，每次调用返回text里的下一括号及其位置""" i, text_len = 0, len(text) while True: while i &lt; text_len and text[i] not in parens: i += 1 if i &gt;= text_len: return yield text[i], i print(text[i]) i += 1 st = SStack() # 保存括号的栈 for pr, i in parentheses(text): # 对text里各括号和位置进行迭代 if pr in open_parens: st.push(pr) # 如果是开括号，就押进栈 elif st.pop() != opposite[pr]: # 如果不匹配就失败 print("Unmatching is found at", i , "for", pr) return False else: pass # 因为成功了，就啥都不做 print("All parenthese are correctly matched") return True 表达式的表示、计算和变换 后缀表达式的计算： 生成一个判断对象类别的函数（是运算度还是运算对象？）nextItem() 如果是运算对象，存起来以备后续is_operated() 如果是运算符（假设都是二元运算符），则取得前面的对象或者已经运算得到的结果，进行计算并保存结果。 这就涉及到存储结构的问题。因为每次结果都不能直接使用，而是应当缓存起来，以备后续。 需要记录的是已经掌握的数据 每次处理运算符都应该用最后记录的几个结果（二元运算符就是2）。 给出算法框架如下： 123456789while 还有输入: x = nextItem() if is_operand(x): # 是运算对象，转换为浮点数并入栈 st.push(float(x)) else: a = st.pop() # 第二个运算对象 b = st.pop() # 第一个运算对象 … … 现在细化一下。 首先，应当定义一个函数，把输入的字符行分割成项。 12def suffix_exp_evaluator(line): return suf_exp_evaluator(line.split())]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（三）-字符串]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本章重点 KMP算法 python的正则表达式 re的匹配对象（match） 字符集、字符串和字符串操作 由于字符串处理的需要，要求字符集上有一种确定的序关系，称为字符序。故而，对于字符集中任意两个字符，&lt;, =, &gt;三种关系之一成立。 字符串可以被看为是一种特殊的线性表，但是由于字符串有很多自身特殊的处理方式，所以经常会把字符串作为一个整体使用和处理，考虑许多以整个串作为你对象的操作。 字符串的相关概念。 字符串的长度 字符在字符串中的位置 字符串相等(长度和字符) 字典序：字典序是字符串上的一种序关系。从左向右查看的两个串中下标相同的各对字符，遇到的第一对不同字符的字符串决定了这两个字符串的顺序。abc &lt; abd, 且abc &lt; abcd。 字符串拼接 子串关系 前缀和后缀：若存在s1=s2+s′s_1 = s_2 + s&#x27;s​1​​=s​2​​+s​′​​，则称s1s_1s​1​​为s2s_2s​2​​的一个前缀。后缀同理。s的开头/结尾的任何一个子串都是它的前缀/后缀。空串和s既是s的前缀，也是s的后缀。 字符串的实现 在实现字符串时，需要考虑两个问题 字符串的存储：全部放在一起存储太占空间，而一个一个存储需要很多链接域，额外开销大，故而实际中，可以折中，将字符串分段保存在一组存储块里，并链接起这些存储块。 串结束的表示：①用数据域记录编码长度。②用特殊编码表示结束。 字符串匹配（子串查找） wiki网页：字符串搜索 朴素的串匹配算法 123456789101112def naive_matching(t, p): #查找t中是否有子串p m, n = len(p), len(t) i, j = 0, 0 while i &lt; m and j &lt; n: # 当i == m时找到了匹配 if p[i] == t[j]: # 该字符匹配，进行下一位的匹配 i += 1 j += 1 else: i, j = 0, j - i + 1 # 该字符不匹配，故而从字符串的下一位开始继续匹配。（ if i == m: # 找到了匹配的子串，返回其起始下标 return j - i return -1 # 无匹配，就返回特殊值 其中，j-i+1就是考虑的从字符串上次开始的下一位开始匹配。 该算法的最坏情况是每次都在最后一位匹配失败，需要匹配m×(n−m+1)m\times (n-m+1)m×(n−m+1)次，所以算法复杂度为m*n。 无回溯串匹配算法（KMP算法） KPM算法的分析 基本思想是对于已经匹配过的元素无回溯。 如果模式串pip_ip​i​​和某个tjt_jt​j​​匹配失败了，下一步是找一个ki(1&lt;ki&lt;m)k_i(1 &lt; k_i &lt; m)k​i​​(1&lt;k​i​​&lt;m)，将模式串后移若干位，匹配pkip_{k_i}p​k​i​​​​和tjt_jt​j​​。 问题的关键就是如何确定kik_ik​i​​。实际上，对于模式串中的每一个元素i,都应该有一个确定的kik_ik​i​​和它一一对应。通过对模式串本身的分析，得到相应的kik_ik​i​​并存储起在pnext[i]表中。 有一种特殊情况是，某pip_ip​i​​匹配失败后，发现之前做过的匹配都没有价值，则下一步就需要从头开始，用p0p_0p​0​​和tj−i+1t_{j-i+1}t​j−i+1​​比较1。针对这种情况，取pnext[i] = -1 KPM算法的实现 假设已经做出了pnext表，以下考虑KMP算法的实现： 注意这里有两个指针，指针i指向匹配串p,指针j指向被匹配串t。 1234567while j &lt; n and i &lt; m: # i == m 说明找到了匹配 if i == -1: # 遇到-1的话匹配下一对字符，j和i同时往后挪。 j, i = j + 1, i + 1 elif t[j] == p[i] # 如果相等，就再比较下一对字符，j和i也同时往后挪。 j, i = j+1, i+1 else: i = pnext[i] # 取第i个字符的 其中，if语句中的两个分支可以合并，有： 12345678910111213# 核心循环步骤def matching_KMP(t, p, pnext): '''KMP串匹配，主函数 ''' j ,i = 0, 0 n, m = len(t), len(p) while j &lt; n and i &lt; m: if i == -1 or p[i] == t[j]: j, i = j + 1, i + 1 else: i = pnext[i] if i == m: return j-i return -1 构造pnext表：分析 如果在位置i匹配失败，那么位置i对应的pnext[i]这个位置应该满足两个条件： 选择的该位置的前缀子串，应该和i前相同长度的子串一致 如果满足上述条件的位置不止一个，则应该移动最短距离，以防止有匹配的遗漏。 实际上，经过一波分析，问题被转化成为：寻找匹配串p中，前i个位置的最长的相同的前缀和后缀。k就是它们的长度，只有这样才能保证不会跳过可能的匹配。 以下是设计出的巧妙算法： 若已经对pnext[i-1]计算出结果为k-1,再比较p[i]和p[k]，有两种情况： 如果pi=pkp_i = p_kp​i​​=p​k​​,说明对于i的最长相等前后缀的长度，比对i-1的最长相等前后缀的长度多1，由此，应该把pnext[i]设置为k，然后考虑下一字符。 否则，应该把p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀拿来做检查。（注意这里只是检查而没有设置，因为p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀也是p0...pi−1p_0...p_{i-1}p​0​​...p​i−1​​的某一个相等前缀（不一定是最长的），所以可以拿来做检查。 如果是已知pnext[0]=-1和直至pnext[i-1]的已有值求pnext[i]的算法： 假设pnext[i-1]=k-1,如果pi=pkp_i=p_kp​i​​=p​k​​，那么p0...pip_0...p_{i}p​0​​...p​i​​的最长相等前后缀的长度就为k，设置pnext[i]=k，将i+1后继续循环； 如果pi≠pkp_i \ne p_kp​i​​≠p​k​​，则设置k = pnext[k]（转去考虑前一个更短的，又能保证匹配的前缀）； 若k=−1k=-1k=−1（等于-1是从第二步pnext来的），则p0...p1p_0...p_1p​0​​...p​1​​的最长相等前缀的长度就是0，设置pnext[i]=02,然后将i+1后继续递推。 这里k就是最长相等前缀个数，它也是一个指针 KMP算法的时间复杂度是O（m+n）. 字符串匹配问题 串匹配、搜索的不同需要 人们需要查找的是具有某种形式的字符串。&lt;\font color = gray&gt;（比如re包里的正则匹配？）&lt;\font&gt; 通配符：比如*，与任意一串字符串匹配；?，与任何一个实际字符匹配。 正则表达式（Regular Expression）。 Python的正则表达式语言 基本情况 原始字符串 在普通字符串前加上“r”或者“R”，内部的“\”不进行转义。 元字符（特殊字符） 共14个，这些元字符起着特殊的作用： $ . ^ * + ? \ | { } [ ] ( )$ 主要操作 字符操作 生成正则表达式对象：re.compile(&lt;正则表达式&gt;) r1 = re.compile(&quot;abc:) 这样做的好处是可以避免重复生成正则表达式 检索：re.search(&lt;正则表达式&gt;, &lt;字符串&gt;) 若找到，则返回一个match类型的对象。否则，返回None。match类型的对象还可以被作真值直接进行逻辑判断。 匹配：re.match(&lt;正则表达式pattern&gt;, &lt;字符串string&gt;) 检查string是否存在和pattern匹配的前缀，如果找到则返回一个match类型的对象；否则返回None。match对象里记录的是成功匹配的相关信息。 例如： 12re.search(r1,'aaabcbcbabcb') # 将匹配成功re.match(r1, 'aaabcbcbabcb') # 将匹配失败 分割：re.split(pattern, string, maxsplit, flag = 0) 12345re.split(' ', "aaa bbb abc are not the same")&gt;&gt;&gt; ['aaa', 'bbb', 'abc', 'are', 'not', 'the', 'same']re.split[" ", "a b c d"]&gt;&gt;&gt; ['a', 'b', '', 'c', '', '', 'd'] #得到几个空串 找出所有匹配串：re.findall(pattern, string, flags = 0) 字符组 字符组形式：[……]，其中的元素顺序不重要。它会和字符组中的任何一个字符串匹配，称为字符组描述。例如，[abc]可以和a或b或c进行匹配。 区间形式：【0-9][a-z],它还可以和字符列表混写，比如[34ad-fs-z] 特殊形式[……]它表示的是对于之后列出的字符组求补。即这种字符组表达式与所有没有列在括号里的字符串匹配。比如，[0-9]匹配非十进制数字的所有字符。 注意如果需要在字符组里包含&quot;[]“或者“^”，则都应该在前面加上&quot;\”进行转义。 圆点字符(.)，这是一个能匹配任何字符的通配符。 例如，模式串a…b匹配所有以a开头b结尾的四字字符。 例如，p\w\w\w可以和p开头随后为任意三个字母数字的串进行匹配。 重复描述符（*） 例如，模式a*要求匹配模式a能匹配字符串的0次或者任意多次重复。re.split('[ ,]*, s)可以把按照任意多个空格或者,来分割s。 在考量重复匹配时，如果有多个子串满足条件，有两种匹配方式： 贪婪匹配：匹配最长子串 非贪婪匹配（吝啬匹配）：模式有可能匹配的最短子串。 此外，“+”表示至少一次匹配。 可选描述符 “a?&quot;表示和a的0或1次重复匹配。 重复次数描述符 a{n}表示和a匹配的串的n次重复匹配。 重复次数范围描述符 a{m, n},a{,n}(等价于a{m,n})，a{m,}等价于a{m, infinity} 注意*、+、？、{m,n}都采用贪婪匹配规则。 非贪婪匹配描述符： *？，+？，？？，{m,n}?采用的都是非贪婪匹配策略。 选择 选择描述符：|，它的结合力是最弱的，比顺序组合的结合力还要弱。 首尾描述符 行首描述符：以“^&quot;符号开头的模式，只能与一行的前缀子串匹配。 12re.search('^for', "books for children") # 结果为Nonere.search("^for", "books \nofor children") # 匹配成功 行尾描述符：以&quot;$&quot;符号结尾的模式，与一样的后缀子串匹配。 12re.search("$fish", "cats like to eat fishes") # 结果为Nonere.search("$like", "cats like\neat fishes") # 匹配成功 匹配对象（match对象） 逻辑：match对象总表示逻辑为真，所以可以被用作逻辑判断 取得子串：mat.group() 在目标串里的匹配位置：mat.start() 取得mat代表的成功匹配在目标串里的实际匹配位置。 目标串中被匹配子串的结束位置：mat.end() 目标串里被匹配的区间：mat.span() 得到匹配的开始和结束位置形成的二元组。也就是说 1mat.span() == mat.start(), mat.end() 其他：mat.re和mat.string（这两个表达式是数据域访问，不是函数），分别取得这个match对象所做匹配的正则表达式对象和目标串。 模式里的组（group） 圆括号表示模式段中的一个组。使用mat.group(n)来调取与其中第n组匹配的字符串。mat.group(0)表示与整个模式匹配的字符串。 另外，match.groups将得到一个序对。 组的另外一个用途是，在匹配中应用前面的成功匹配。比如r&quot;(.{.{2}) \1可以匹配&quot;ok ok&quot;（两个字符，加一个空格，然后匹配相同的内容），不能匹配“oh no&quot; 其他匹配操作 re.fullmatch(pattern, string, flags = 0)，若整个string和pattern配对成功，返回match对象 re.finditer(pattern, string, flags = 0)，和findall类似，但是它会返回一个迭代器，顺序取得各非重叠匹配得到的match对象。 re.sub(pattern, repl, string, conut = 0, flags = 0)，生成替换结果的串。repl可以直接是一个字符串，也可以是一个以match对象为参数的函数。用其调用match对象的返回值来替换被匹配的子串。 正则表达式对象 re.compile(pattern)生成一个正则表达式对象。除了用来搜索外，它本身还支持另一组方法，功能也更强。以下用regex来表示一个正则表达式对象，它有这样一些方法： 检索：regex.search(string[,pos[,endpos]])，可以指定检索的开始和结束位置。 匹配：regex.match(string[,pos[,endpos]])，也可以指定匹配区间。 完全匹配：regex.fullmatch(string[,pos[,endpos]])，检查string中由指定范围构成的子串是否和regex匹配。 正则表达式的使用 如果目标串中存在一些（或者很多）与正则表达式匹配的子串，需要逐个处理，在这种情况下采用迭代器的方式最方便。编程模式是： 1234rel = re.compile(pattern)for mat in rel.finditer(text): ...mat.group()... # 取得被匹配的子串，做所需操作。 ... text[mat.start()]...text[mat.end()]... 不过这种写法有点繁琐，拿到这种字符串，先考虑能不能用re.sub进行处理，如果实在不行再用迭代器方案。 单词边界 \b描述单词边界。但是，python字符串中\b表示退格符，这两个重复了。有连个方法可以解决这个问题 模式串中的\双写。 模式串采用原始字符串的形式（加上r) python程序里的整数匹配可以写为：r'\b(0+|[1-9]\d*)\b' 若是希望匹配带有正负号的一般整数，可以写为：r'\b[+-]?(0+|[1-9]\d*)\b 补充 为了方便，re还提供了如下以转义串形式定义的常用字符组，包括： \d: [0-9] \D: [^0-9] \s: [ \t\v\n\f\r] 即与所有空白字符进行匹配 \S: [^ \t\v\n\f\r] 与所有非空白字符进行匹配 \w：[0-9a-zA-Z] \W：[^0-9a-zA-Z] 1.这里我觉得书中描述不清，应当是直接从上一次匹配的下一个进行匹配，所以应当是$t_{j-i+1}$而不是$t_{j+1}$开始匹配 ↩2.这个地方有一点奇怪，如果设置为0的话，-1是哪里来的…… ↩]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>数据结构，python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《道林·格雷的画像》摘抄]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近来疯狂迷恋王尔德。 书没有道德和不道德之分，只有写得好的和写得差的，仅此而已。 “哦，我也说不清楚。当我心有挚爱时，我绝不向任何人说出他们是谁，说出来就好比一点点出卖他们。我愈来愈喜爱隐秘了，这样似乎能使我们体会到现代生活的秘密和美妙。” 顺其自然才是一种姿态，而且是据我所知最令人恼火的姿态。 至于信不信的问题，只要不可信的，我都相信。 或者就敌意而言，何为敌意？你对人人都喜欢，也就是说，你对人人都漠然。 1 我交朋友，都是因为他们长得好看（哈哈哈哈哈）；我结识人，都是因为他们有好的性格；我选敌人，都是因为他们有智慧。 但无疑天赋比美貌更持久，这也是我们都拼命接受过多教育的原因。在疯狂的生存竞争中，我们都希望拥有某种持久不灭的东西，所以我们用垃圾和事实填满我们的思想，愚蠢地希望保持自己的地位。无所不知的人——这就是现代人的理想，而无所不知的人的思想让人感到恐怖。它就像一个小古董店，里面只有怪物和灰尘，一切都价过其实。 ——“世上没有‘好道德’这种东西，格雷先生。所有影响都是不道德的，从科学的角度看，都不道德。” ——“为什么？” ——“因为影响一个人，就是把自己的灵魂给他。他就不会依从自己的天性思考，或让自己天性的激情燃烧。他的美德不真的属于他。他的罪孽，要是有罪孽存在的话，也都是借来的。他成了别人音乐的一个回声，一个并非为他而写的剧本中的演员。生活的目的就是自我进步，要完全释放自己的天性——这是我们每个人来到人世的目的。现如今，人们竟怕起自己来了。他们忘记了自己的最高职责，即对自己应付的责任。 我相信，如果一个人能活得充分、彻底、表现出每一种感情，表达出每一种思想，实现每一种梦想——我相信，世界会获得如此新鲜的喜悦的冲动，会因此使我们忘掉中世纪时代的所有弊病，重回希腊的理想——可能是某种比希腊理想更美好，更富饶的东西。 只有感官才能拯救灵魂，就像只有灵魂才能拯救感官一样。 美是世上的一大客观存在，就像阳光、春光，或者我们称之为月亮的，银色贝壳般在水中的倒影，这是毋庸置疑的。 人有时会说美只是一种肤浅的东西。或许如此，但至少不会像思想一样肤浅。对我而言，美是奇迹中的奇迹。只有浅薄之人才不以貌取人。世界真正的神秘存在于可见之物，而非不可见之物。 啊！当你拥有青春时，你就要认识到它。不要虚掷你的黄金岁月，去听冗长乏味的说教，试图弥补无妄的失败，或把你的生命献给无知、庸常和低俗。 活着！活出你宝贵的内在生命。什么都不要错过，始终去寻找新的感受。无所畏惧…… 现在的人啊，什么东西的价格都知道，但它们的价值，都不知道。 男人结婚是因为厌倦，女人结婚是因为好奇，结果是双方都感到失望。 我不是在笑，道林，至少不是在笑你，但你不该说这是你一生中最浪漫的事。你应当说是你一生中的第一次浪漫。你会一直有人爱，你也会一直爱上爱，多情是无所事事者的特权，一生只爱一次的人才是真正的浅薄之人。他们自称忠实、忠诚，我则称之为习惯懒惰，或是缺乏想象。忠诚之于感情生活，就像惯性之于理智生活——都只是承认失败。忠诚！将来我一定要研究研究这个东西。其中包含着对财产的贪欲。如果不是因为害怕被别人捡走，我们肯定要扔掉很多东西。2 拿别人的悲苦做谈资，总归是及其卑微的。 人都爱放弃自己随需要的东西，这就是我所谓的慷慨的深意。 好的艺术家，都只存在于他们的作品之中，他们本人都是极其无聊乏味的。伟大的诗人，真正伟大的诗人，都是世间万物中最没有诗情画意的家伙。但蹩脚诗人，却绝对魅力四射。诗写得越拙劣的诗人，看上去却越动人。 但经验中没有驱动力。它与良心一样，都不是积极的动因。实际上它所能昭示的一切，无非是我们的未来与我们的过去一模一样，我们曾经带着厌恨犯下的罪孽，我们会带着愉悦一再犯下去。 现如今，任何事我都不说赞成还是不赞成。这种带着生活的态度是荒谬的。我们被送到人世间，不是为了宣扬我们的到的偏见的。 我们之所以都喜欢把别人往好处想，是因为我们都为自己感到害怕。乐观主义的基础就是纯粹的恐惧，我们称赞邻居拥有那些美德，就以为我们自己慷慨，实际上只是因为那些美德可能对我们有利。我们赞扬银行家，只为可以透支；我们找出拦路强盗的优点，只是希望他会饶过我们的口袋。我说的话都当真。我最鄙视乐观主义。至于说生活被毁，没有什么生活会被毁，只有生长被遏制才是真的毁了。如果你想破坏一个人的本性，你只需改造它。 “‘善’，就是要与自身和谐。”他用苍白尖细的手指碰了碰手中杯子的细柄，说，“不和谐，就是被迫与他人维持和谐。人自身的生活才是重要的，至于周围人的生活，假如有人想做道学先生或清教徒，他尽可抒发自己的道德观念，但不管别人的事。除此之外，个人主义其实抱有更崇高的目标。现代道德就体现在接受自己时代的标准。而我认为，对任何一个有教养的人而言，接受自己时代的标准就是一种最严重的不道德。” 陈年旧事的唯一魅力，在于它已成旧事。 我们生活在一个读书太多反而愚蠢的年代，一个思考太多反而不美的时代。 表达赋予事物真实存在。 “做过就做过了，过去的已经过去了。”“你称昨天是过去？”“这与时间的实际长短有什么关系？只有浅薄的人才需要数年来摆脱一桩感情。” 人天生害怕比自身强大的激情和感觉，他们意识到自己与低级生物有同样的欲望和感受。 当然，这种新享乐主义是服务于理智的，不接受任何形式的，以牺牲情感体验为代价的理论或体系。事实上，它的目的就是体验本身，而非体验的结果，不管这种结果是苦是甜。禁欲主义使感觉丧失，庸俗的纵情挥霍使感情迟钝，这与新享乐主义无关。它要教会人珍视生活的一个个瞬间，而生活本身就如同一个瞬间。 山风呜咽叹息着，盘旋在寂静的房子周围，似乎担心惊醒沉睡者，却又必须把睡神从紫色的山洞中唤醒。层层叠叠昏暗的薄纱揭开了，万物渐渐恢复了形状和颜色，我们看着黎明以它古老的方式重塑世界。暗淡的镜子又开始它映射事物的一天，数支熄灭的细蜡烛依旧立在原地，旁边摆着一本裁了一半的书、在舞会上戴的用金属丝扎着的花儿，或者一封不敢读或读了太多遍的信。在我们看来，似乎什么都没变。熟识的现实生活从虚幻的夜影里回来了，我们不得不从原来中断的地方重新开始生活，一种可怕的感觉悄然袭来，我们必须在一成不变、让人厌倦的陈规里葆有继续的力量。 与生活本身相比，他似乎觉得没有什么理论是举足轻重的。 社会——至少文明社会——从不会轻易相信任何对有钱又有魅力的人的诋毁。 人是一种具有多重生活、多层感觉、多种形式的复杂生物，人的精神秉承了思想和激情的奇怪遗产，人的肉体沾染上了祖先的可怕疾病。 人既有文学上的祖先，也有血缘上的祖先，可能很多人在类别和性情方面与文学上的祖先更接近，也更能明显地意识到。有时，道林似乎觉得，整个人类历史都只不过是自己生活的记录，不是它的实际生活，而是他想象中创造的生活，在他的脑海和激情里。道林觉得仿佛认识那些奇怪而可怕的历史人物，他们在世界舞台中登场，又离开，把罪孽变得如此神奇，把邪恶变得如此微妙。他仿佛觉得，他们的生活通过某种神秘的方式，变成了他的生活。 我们每个人身上都既有天堂又有地域。 它曾一度厌恶丑陋，因为丑陋让事物显得真实，而现在恰恰因为这个原因，他觉得丑陋可爱。丑陋是唯一的真实，粗鲁的争吵、可恶的贼窝、乱糟糟的生活中粗野的暴力、窃贼和流浪汉的肮脏……这些给人留下强烈真实的印象，比一切艺术的优雅表象和音乐的梦幻影子生动得多。 每个人都有自己的生活之道，也都会为此付出代价。唯一的遗憾是人不得不因为一次过错不停地付出代价。实际上，是一而再、再而三地偿还。命运与人做交易，从不结清账户。 我不怕死，我怕的是死亡的临近。可怕的死亡之翼似乎就盘桓在我周围沉闷厚重的空气中。 现如今，除了死亡，人可幸免于一切。 灵魂一种可怕的现实。可以买可以卖，可以交换，可以予以毒害，或完善。我们每个人内心都有一颗灵魂。 只要能恢复青春，我愿意做任何事，除了锻炼、早起和道貌岸然。 老年人的悲剧不在于老了，而在于还想年轻。 青春是什么？至多只是一段青葱、幼稚的时光，充满了浅陋的情绪和病态的思绪。为什么他要做青春的奴仆？青春已经把他毁了。 1.把这句话发给导师之后，她说“对人人都漠然”简直很你了。 ↩2.这简直是我看到现在对于占有欲最通透的解释！ ↩]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>王尔德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（二）-线性表]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本章重点 线性表的定义 顺序表和链接表 线性表的概念和表抽象数据结构类型 表的概念和性质 E中一组有穷个元素排成的序列。表中包含的元素的个数成为表的长度。元素之间的关系成为“下一个关系”，这是一种顺序关系，也称为线性关系，是一种线性结构。 线性表的操作 一个线性表可以提供的操作有： 创建线性表的操作； 获取表中信息的解析操作（判断是否为空） 动态改变表的内容； 表的组合操作（merge，subset……） 对表元素的遍历问题（给定对单个元素的操作，也存在可以对表进行的操作） 最后的这两类可以实现变动操作（直接在原表基础上修改）或者非变动操作（在原表基础上产生新表）。 线性表的实现 基本考虑： 考虑计算机内容的特点，还有保存元素和元素顺序信息的需要。 各种重要操作的消耗。比如is_empty这种，消耗越小越好。 两种实现模型 顺序表：表中元素顺序地存放在一大块连续的存储区里； 链接表：通过连接构造起来的一系列存储块里。 基本实现方式 表里保存的元素类型相同。 在顺序表中，可以通过Loc(ei)=Loc(e0)+c * i来计算出ei的位置。时间复杂度为O（1）。 元素类型（长度）不同 这个时候可以考虑将实际元素另外存储，而在顺序表里各单位位置保存相应位置的引用信息（链接）。 顺序表 基本操作的实现以及时间复杂度 创建和访问操作 简单判断（是否为空，大小）：O（1） 访问指定下标为i的元素：O（1） 遍历操作：给定一个i，然后每次+1（向下）或者-1（向上），时间复杂度为O（n） 查找给定元素d（第一次出现）的位置：检索/查找。 不改变结构的操作，有两种：直接访问，时间复杂度为O（1）；或者基于一个整型变量循环得到结果的，时间复杂度为O（n） 变动操作：加入元素 在尾端加入数据：O（1） 在第i个位置加入元素：有两种情况 不需要保持原来的相对位置：把i的元素移动到位置num。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 变动操作：删除元素 尾端删除：O（1） 在第i个位置删除元素：也有两种情况 不需要保持原来的相对位置：把num-1的元素移动到位置i。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 基于条件的删除：因为需要对元素进行遍历，故而时间复杂度也为O（n）。 顺序表的结构 顺序表可以用两种储存结构： 一体式结构：存储表信息的单元和元素存储区被安排在一块存储区里； 分离式结构：存储表信息的单元和元素存储区不被安排在一起，通过一个连接实现相连。 分离式结构扩容 替换元素存储区： 分离式结构的优势，可以在标识不变的情况下，为表对象换一块存储区。（可以改变表的容量）。 替换策略：容量加倍 每次更换存储区的时候，加倍容量:1,2,4,……。 这样算下来,总元素为n个时，时间复杂度为O（n），平均每个元素的时间复杂度为O（1）。 链接表 基本思想 表中的元素独立存储； 组成表结构的任一结点可以找到与其相关的下一结点； 前一节点中，用链接的方式显式地记录与下一结点之间的关联。 单链表 结点为二元组，表元素域中保存折作为表元素的数据项以及同一个表里下一个结点的标识。以下定义一个结点类 1234class LNode: def __init__(self,elem, next_ = None): self.elem = elem self.next = next_ 基本链表操作 创建空列表 删除链表 判断表是否为空 判断表是否满 加入元素 表首端插入： 123q = LNode(13)q.next = head.nexthead = q 一般情况的元素插入 创建新结点q并存入数据； 把pre所指结点next域的值存入新结点q的链接域next. 把pre结点的next域改为q 123q = LNode(15)q.next = pre.nextpre.next = q 删除元素 删除表首元素：更改表头指针，将其指向下一个结点即可。 1head = head.next 一般情况的元素删除：一般情况要先找到pre结点，将其next域指向被删结点的下一结点即可。 1pre.next = pre.next.next 扫描、定位和遍历 扫描 已知信息只有表头，故而只能从表头开始往下扫描： 1234p = headwhile p is not None and &lt;其他条件&gt;: &lt;对p进行操作&gt; p = p.next 后续为Python代码的实现，详细可以点击这里 两个链表的操作 链表翻转 python list类的reverse操作，可以实现两个元素互换。 *注意：如果使用单链表，则耗时会是O（n^2) 链表排序 python中的list对象有一个sort方法，可以实现排序。 单链表排序的实现过程。 从第1个元素开始循环，取出第i个元素。假设i前面的j个元素已经排好序了。 将i元素和j元素一一比较。如果第j个元素比i大，则将其右移一位； 直到找到比i小的元素为止，将i插入该空位。 以下为实现方法： 12345678def list_sort(lst): for i in range(1, len(lst)): #假设开始时[0:1]已经排序 x = lst[i] j = i while j &gt; 0 and lst[j-1] &gt; x: lst[j] = lst[j-1] j -= 1 lst[j] = x 单链表实现方法见笔记 总结 几种类型的表 基本单链表支持O（1）时间的前端插入&amp;删除工作；而定位和删除尾端都市O（n）时间 增加尾结点的单链表支持O（1）时间的首端/尾端插入和首端弹出，但不支持高效尾端删除; 循环单链表支持高效的首端/尾端插入和首端删除，但要注意结束条件； 双链表支持高效的首端/尾端删除和输入。 链接表的优点 表结构容易修改和调整 不需要修改结点的数据元素 方便管理（尽管python不需要管理） 链接表的缺点 定位访问需要线性时间 双链表在实现高效访问前后元素的时候，需要更多的存储空间。 存储一个表元素，就还需要存储一个链接域 表的应用 Josephus问题 代码依然见这里 第一种实现方法josephus_A由于需要遍历，算法复杂度很麻烦。这里暂时不细纠了。 第二种实现方法基于顺序表，见josephus_L，这种实现方式的复杂度为O（n^2） 第三种基于循环单链表，创建了一个Josephus类。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（一）-抽象数据结构]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhon%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[抽象数据类型的概念 一个数据类型的操作通常可以分为三类： 构造操作：基于已知信息，产生同样类型的新对象； 解析操作：基于已知信息，产生不同类型的新对象； 变动操作：修改被操作对象的内部状态。 静态方法和类方法 静态方法：通过在类前添加修饰符@staticmethod实现，本质上为普通函数。它没有self参数； 类方法：以访问属性的形式调用，调用它的类将自动约束到方法的cls参数。可通过该参数方位该类的其他属性。 在编程过程中，__init__方法通常都用来检查参数的合法性，设置参数的数据属性。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（五）-类和对象]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（五）——CHAP6 类和对象 重点： 类的构造方法 类 类的声明 类体 类体中包含变量的声明以及类方法的定义。 类的构造方法 构造方法的名称和类名相同 没有返回类型，返回值，也不需要修饰符 虽然看起来和一般的成员方法没有区别，但不能被直接调用，只能被new运算符调用 构造方法不能被继承（因为它不是类的成员） 子类可以调用父类的构造方法 【举个栗子】 创建一个car类并调用。 1234567891011121314151617181920212223242526class Car&#123; private String Brand; int gas; Car (String vBrand, int vgas )&#123; //构造方法 Brand = vBrand; gas = vgas; &#125; void run()&#123; if (gas &gt; 0) gas -=10; else System.out.println("没油了，不能跑啦~"); &#125; void Disp()&#123; System.out.println("品牌："+Brand+"油量"+gas); &#125;&#125;class Example6_1&#123; public static void main(String args[])&#123; Car MyCar = new Car("Audi", 10); //创建对象mycar MyCar.Disp(); //调用disp方法 MyCar.run(); //调用run方法 System.out.println("car is running……"); MyCar.run(); &#125;&#125; 成员变量]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（四）-数组]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（四）——CHAP5 数组 重点： java的高维数组每一个维数可以不一致 冒泡排序法 数组是用相同类型的元素组成的集合。这些元素可以是基本数据类型，也可以是构造出的数据类型。 包含以下几个部分： 数组名 数组类型 数组长度（有几个元素？） 数组中的元素是有顺序的。 一维数组 声明： int a[];或者int [] a;均可。 初始化： 直接在声明时初始化：int a[] = {1,2,3};，可用于元素较少的时候。 但是不能先声明再使用静态的初始化: 12int a[];a = &#123;1,2,3&#125;//会报错! 为数组分配内存空间，后续再赋值 12类型 数组名[];数组名 = new 类型[数组长度]； 例如： 12345int a = new int[4];a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; 【举个栗子】 实现冒泡升序排列 12345678910111213141516171819public class BubbleSort&#123; public static void main(String args[]) &#123; int i,j; int intArray[] = &#123;35,22,51,10,60&#125;; int len = intArray.length; for (i = 1; i &lt; len; i++) for (j = 0; j &lt; len - i - 1; j ++) if (intArray[j] &gt; intArray[j+1]) &#123; int t = intArray[j]; intArray[j] = intArray[j + 1]; intArray[j + 1] = t; &#125; System.out.println("the result after bubblesort: "); for (i = 0; i &lt; len - 1; i ++) System.out.println(intArray[i]); &#125; &#125; 把数组传递给方法 多维数组 二维数组的声明&amp;创建 声明： 12int a[][];double [][] b; 分配内存空间 直接为每一维分配空间： int a = new int[2][3];创建一个2*3维的数组； 从最高维开始分配：123int b = new int [2][];b[0] = new int[3];b[1] = new int[5]; 得到的形式如下： b[0][0] b[0][1] b[0][2] b[1][0] b[1][1] b[1][2] b[1][3] b[1][4] 注意 java数组的每一维不需要等长。 使用new分配内存时，至少需要给出最高维的大小。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（三）-程序流控制结构和方法]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E7%A8%8B%E5%BA%8F%E6%B5%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（三）——CHAP4 程序流控制结构和方法 重点： if elif条件嵌套 多选择结构switch+case 带标号的continue&amp;break 递归算法 switch语句 【举个栗子】switch + 三目条件运算（见笔记（一）） 本例可以把输入的字符串转换成数字： 以及在Java中，用双引号&quot;&quot;括起来的为String,用单引号’'括起来的是Char 12345678910111213141516171819202122232425262728293031import java.io.*;class SwitchTest2&#123; public static void main(String args[]) throws IOException &#123; char ch; System.out.print("enter a month: "); //这里是因为没有办法输入10,11,12这种两个字符的字节,故而用a,b,c代替 ch = (char)System.in.read(); &#123; System.in.skip(2); switch( (ch == '1'||ch == '2'||ch == 'c')?1: (ch == '3'||ch == '4'||ch == '5')?2: (ch == '6'||ch == '7'||ch == '8')?3: (ch == '9'||ch == 'a'||ch == 'b')?4:5) &#123; case 1: System.out.println("春季"); break; case 2: System.out.println("夏季"); break; case 3: System.out.println("秋季"); break; case 4: System.out.println("冬季"); break; default:System.out.println(ch + "是无效月份！"); &#125; System.out.print("switch语句出口！"); &#125; &#125;&#125; 结构化编程 for 循环 for(初值表达式1;循环条件表达式2;循环变量修改表达式3) 注定一定要确定循环条件，以防陷入死循环。 【举个栗子】计算1-100整数之和 123456789class LoopTest3&#123; public static void main(String args[])&#123; System.out.println("0-100 个整数之和 ：\n"); int i, sum = 0; for(i = 1; i &lt;= 100; i++) sum += i; System.out.println("sum=" + sum + ",i =" + i ); &#125;&#125; 另外，如果i是循环for里面定义的，则只在循环内有效。 【补充】用for循环实现和while一样的结构 123456int x = 10;for (;;;)&#123; if ( x &gt; 0) break; x -- ;&#125; 这时则需要和break结合。 嵌套循环和continue和break 带标识的continue 添加一个合法的JAVA标识符，并在其后面跟上冒号。 【举个栗子】 1234567891011121314151617181920import javax.swig.JOptionPane;public class ContinueLabTest&#123; public static void main(String args[]) &#123; String output = ""; rownext：//添加标识符 for (int row = 1; row &lt;= 5; row ++) &#123; output += "\n"; for(int column = 1; column &lt;= 10; column ++) &#123; if (column &gt; 2 * row - 1) continue rownext; //这里就是带标识的地方，跳出第二层for循环，回到外层的循环并判断循环条件。 output += "*"; &#125; &#125; JOptionPane.showMessageDialog(null, output, "testing continue with a label", JOptionPane.INFORMATION_MESSAGE); System.exit(0); &#125;&#125; break语句 break语句除了放在循环里，还能放在switch里。 break也可以带标号，常用在跳出多重循环里，只要在想跳出的循环前面加上break标号。 算法设计 这里先看一个基础的：递归 【举个栗子】用递归方法求阶乘LoopDGc 123456789101112131415class factor&#123; public long factorial(long n)&#123; if (n == 1) return 1 else return n * factor(n-1) &#125;&#125; public class LoopDGc &#123; public static void main (String args[]) &#123; long n = 20l; factor a = new factor(); long result = a.factorial(n); System.out.println(" "+n+" 的阶乘为" + result); &#125;&#125; 实际上这个地方还没怎么明白，尤其是主类和普通类。 首要还是要明白递归是什么东西……]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（二）-输入和输出]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（二）——CHAP3 Java的输入和输出 重点： System.out.write() 流式交互(InputStreamReader + BufferedReader) 标准输入/输出方法 Java里System包提供输入/输出流。 输出方法 println()输出后换行； print()输出后不换行； write()则被用来输出字节数组 以下举例： void println(char[] X)输出一个字符数组 void write(int b [])输出字节数组中的某一个元素，其后不换行。 123456789class PrintDemo&#123; public static void main(Strng args[])&#123; byte b[] = &#123;'f','g','h','i'&#125;; System.out.write(b,0,2); System.out.println(); //因为write后不换行，所以这里用println换行 System.out.write(b[0]); &#125;&#125; 输出结果是：fg和f 标准输入方法 用System.in.read()方法，有以下三种格式： 123public abstract in read() //从键盘输入一个字符public int read(byte[] b) //一次输入多个字节，并存在字节数组b中public int read (byte[] b, int off, int len)//限定输入的字节 另外，因为键盘输入很容易出错，所以必须引入异常处理机制。引入格式有两种 在main方法后直接用throws java.io.IOException子句抛出异常； 先在程序开头import java.io.*;加载语句,接着在main方法后加上throws IOExcrption子句来跑出异常。 【举个栗子】在键盘上一次输入多个字符并显示： 12345678910public class ReadCharDemo&#123; public static void main(String args[]) throws java.io.IOException &#123; byte b[] = new byte[16]; //定义长度为16的数组 System.out.println("\n 从键盘输出不超过16个字符，按回车键结束") System.in.read(b); System.out.printlb("\n 从键盘输入的是：") System.out.write(b,0,16);//用write直接输出字节数组。 &#125;&#125; 注意 如果用的是print方法，则需要把每一个元素都转化成字符，比较麻烦。 使用read方法时，还可以用read(b, 0, 10)来限制读入长度。（见上面提到的方法3） 利用命令行传入参数 123456public class HelloArgs&#123; public static void main(String args[]) &#123; System.out.println(args[0] + args[1] + "Hello!"); &#125;&#125; 接着可以在命令行里直接传递参数： 12E:\code\java-learning&gt; java HelloArgs 王可 王小可王可王小可Hello! 流式交互 1234567891011import java.io.*;public class HelloA1&#123; public static void main(String [] args) throws IOException &#123; InputStreamReader reader = new InputStreamReader(System.in); BufferedReader input = new BufferedReader(reader); System.out.print("Enter your name:"); String name = input.readLine(); System.out.println("Hello," + name + "!"); &#125; 这里reader作为InputStreamReader的一个实例存在，并且用作输入的System.in对象与之绑定； 接下在input作为BufferedReader的一个实例，与reader绑定； 用input的readLine方法来从键盘读取一整行的文字即可。 图形界面&amp;自定义类 以后再填坑，目前用不上，跳过。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown必要语法补充]]></title>
    <url>%2F2018%2F09%2F11%2FMarkDown%E5%BF%85%E8%A6%81%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[编号： 使用数字+.+半角空格 代码块高亮 插入数学公式。 可以使用MathJax引擎。如果要用hexo进行部署，且使用的是next主题，则可直接在站点配置文件中更改： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 把enable改为true。 另外，安装hexo-math插件,可以实现MathJax的自动部署： 1npm install hexo-math --save 感受一下： x1+x2=x3x_1 + x_2 = x^3 x​1​​+x​2​​=x​3​​ 编写语法和tex语法一致。]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（一）-语言基础]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（一）——CHAP2 JAVA语言基础 重点：最终变量、三元条件运算、位运算、MATH类 TIPS 注释格式 //表示单行注释 多行注释以/*开始，*/结尾 编程习惯 所有语句以分号结尾； Java区分大小写； 类名称以大写字母开头，变量以小写字母开头； 驼峰命名法； 文件名需要和public类在拼写和大小写上一致； JAVA语言基础 基本构成 标识符 所有标识符必须以A~Za~z，_或者$开头；（尤其注意不能以数字开头）； 流行的命名方式 常值标识符——全部大写： RED 类名标识符——大写字母开头+驼峰：MyCar 公有方法/实例变量——小写开头+驼峰：getCurrentValue 关键字 for while boolean …… 分隔符 注释 空白符（回车、TAB、换行），会被忽略 普通分隔符（{} ; , :） 直接量 运算符 数据类型 基本数据类型 整型：byte, short, int, long; 浮点型：float, double, 字符型：char 布尔型：boolean 直接量 程序中使用的常量 整数、浮点数、布尔值、字符、字符串 变量 一般变量要经历以下几个步骤 声明变量 变量的作用域和生命周期 最终变量 这个概念第一次听说。高亮~ 它指的是在运行过程中值不变的量，有点类似于常量。 定义的方法有两种。 直接定义： final double PI = 3.1415； 在声明的变量前加关键字，必要时再初始化： 123final double PI;……PI = 3.14159； 变量类型的转换 自动转换：两个类型兼容/目标类型大于原类型（比如byte转double) 强制转换 运算符&amp;表达式 只有一点要注意： 1234int i = 10;int j = 10;x = i ++;y = ++ j; x的值为10， y的值为11。所以++的位置要注意 逻辑运算符： !逻辑非 &amp;&amp;逻辑和 ||逻辑或 三元条件运算符 exp1&gt;exp2:exp3 例如： 12x = 10;y = x &gt; 9 ? 100:200 输出y为100，否则y为200 MATH类的操作 Math在JAVA.lang类包里。 调用e和PI:Math.E Math.PI 最大最小化：Math.max(val,val) Math.min(val,val) 绝对值: Math.abs() 四舍五入： Math.round() Math.rint() Math.ceil() Math.floor() 幂和对数:exp(),pow(),log() 三角函数：Math.sin()等]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java10的环境配置]]></title>
    <url>%2F2018%2F09%2F10%2Fjava10%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[好久没碰JAVA，今天重新下了个JDK10，发现配置较之前学习的有所变化。主要是PATH和JRE的环境配置： CLASSPATH配置 首先在环境变量中添加JAVA_HOME为jdk的安装路径； 新建一个CLASSPATH的系统变量，并添加.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 注意前面不要忘记加点和分号。 PATH配置 直接用绝对路径，添加&lt;PATH_TO_JDK\bin&gt; （并不需要把jre也加进去） 验证安装是否成功 老三样，打开cmd，依次输入： 123java -versionjavacjava 都成功就说明装完啦~]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[刚开学没事干，所以想着来搭个博客吧。也是为了激励自己能够养成及时总结的习惯。 hexo+github的博客搭建教程网络上很多，我主要搜了知乎的这一篇，讲得很详细：GitHub+Hexo 搭建个人网站详细教程 此外这个作者的汇总做的也不错：Hexo+GithubPages&amp;CodingPages搭建自己的个人博客 还有这个作者的汇总：我的个人博客之旅：从jekyll到hexo 设置多个tags以及categories 在写这个blog的时候还发现，如果直接在tags后面写多个tags会显示成一个，这是不行的。 这里提供了解决方法：hexo搭建博客–给文章添加多个tag或category 注意这里的categories是直接显示的侧边栏。 以下是一些常用个性化设置： 修改文本链接样式： 链接文本改为蓝色，鼠标划过时文字颜色加深： 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 1234567.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; &#125;&#125; 在侧边栏添加tags： 新建一个页面，命名为 tags： 1hexo new page tags 这会在blog的根目录的source下生成一个tags文件夹，文件夹里面带了一个index.md 点进去，修改： 12345---title: tagsdate: 2018-09-08 15:23:35type: &quot;tags&quot;--- 注意不要忘记在冒号之后打半角空格 增加搜索框 以下是网络上的方法，但是我尝试了一下没啥用= = 首先安装hexo-generator-searchdb插件(在blog的根目录下) 1npm install hexo-generator-searchdb --save 接着，找到站点配置的_config.yml文件，在任意位置添加： 12345search: path: search.xml field: post format: html limit: 10000 以下是next主题配置自带的功能： 在next的_config.yml文件夹下，找到“local_search”这一栏，把默认的false改为“auto&quot;(自动匹配)或者”manual&quot;(手动匹配)即可。 1234567local_search: enable: auto # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 控制预览字数/博文缩略显示 在想要断页的地方添加：&lt;!--more--&gt;，可以精确控制字数； 或者在next的_config.yml文件中，找到auto_excerpt项，然后把底下的false改为true。这样可以控制每篇blog都显示相同的字数。 markdown-it-plus 这个底下有不少插件 首先，卸载原有的渲染工具： 1234npm un hexo-renderer-marked --save#卸载旧的默认Markdown插件npm install hexo-renderer--markdown-it-plus --save#安装新的增强型插件 插入数学公式 使用katex，首先，需要安装katex支持插件： 1npm install markdown-it-katex 接下来，在站点配置文件中，把markdown-it-plus自带的mark关闭，并开启katex： 12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false 配置完之后，还需要在网页中引入相关的CSS文件，如果不想每次都写的话，可以在next主题里themes\next\layout\_custom\header.swig文件中修改，写入如下内容： 这里我踩了个坑，markdown-it-katex官方给的最新的katex文件渲染的上下标有问题，改为下面这个版本后解决了。 12&lt;link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"&gt;# 不要引入最新的katex文件，显示效果和插件并不兼容 接着，安装自动渲染的插件：hexo-math 1npm install hexo-math 然后在站点配置文件中添加如下内容 1234567891011math: engine: &apos;katex&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 就可以啦。实现如下： a2+b2=c1a^2 + b ^ 2 = c_1 a​2​​+b​2​​=c​1​​ 设置脚标 markdown本身是自带脚标的，可以在正文里输入&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在文章末尾加上： 1 即可。 但是hexo并不支持这种渲染。好在markdown-it-plus里也可以设置。在安装了markdown-it-plus插件后，再安装其附属： 1npm install markdown-it-footnote 配置文件只需要写如下内容就可以： 123456789markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ 因为footnote这个插件是默认打开的。如果需要关闭的话，在markdown-it-plus的配置下再添加 1234plugins: - plugin: name: markdown-it-footnote enable: false 就可以。 next 背景的动态化设置。 背景设置在5.1版本之后方便了很多，在next主题配置文件里找到： 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: true# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 这几个是用来配置背景的，可以喜好选择true/false来开启和关闭这些动图。 添加头像 这个很简单，在next主题配置文件中，找到： 12# Sidebar Avataravatar: /images/avatar.jpg 把avatar前面的#去掉即可。头像图片放在next/source/images里。 使用gitment添加评论 我觉得gitment比较方便的是不用另外注册账号了~ 主要参考这篇的配置 添加BGM 1.这是一个备注 ↩]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
