<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VPS + docker快速上手hadoop(linux)]]></title>
    <url>%2F2018%2F12%2F03%2FVPS-docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bhadoop%2F</url>
    <content type="text"><![CDATA[本篇不是教程！不是教程！不是教程！算是一个资源汇总，一小时内搞定hadoop集群，上手hive命令不是梦。 前提是： 装好了docker，docker安装文档 装好了docker-compose（1.10.0版本及以上），docker-compose的官方安装文档 拥有git账号； 拥有docker hub账号； 一个至少2G内存的linux虚拟机/服务器。（内存不够的话，跑hive可能会被强制kill掉） 废话与背景介绍 听闻hadoop环境配置令人作呕，这时候用docker起hadoop，作为练手就非常合适了。 上手只是玩一玩，熟悉一下hadoop架构，如果真的有大量数据处理需求的话，还是要老老实实自己搭集群哦。 预备：Xshell连接服务器 如何利用Xshell链接远端服务器。点这里 Xshell快速上传本地文件，点这里 纯hadoop集群搭建 Docker Hub上排名第一位的是uhopper/hadoop,利用docker-compose实现hadoop集群的部署。 无脑拉一个前人的工作下来，推荐这位小哥的博客，博客里提供了git clone的地址。 查看服务器中namenode的IP地址，在命令行中输入： 1$ docker inspect namenode | grep IPAddress 会得到输出结果，我的结果是： 123"SecondaryIPAddresses": null, "IPAddress": "", "IPAddress": "172.18.0.2", 利用Xshell的隧道功能，可以将服务上的172.18.0.2/50070映射到本地的localhost，方便查看集群状态。 上手hive 该项目和上面hadoop的docker是完全独立的，上述的hadoop的docker-compose只是搭建了一个干净的hadoop集群，而下面的docker则进一步实现了hive。 这里给出一个人气很高的docker-hive仓库 首先，拉取仓库：git clone https://github.com/big-data-europe/docker-hive.git 进入文件夹中：cd docker-hive 起docker-compose： docker-compose up -d (作者还提供了其他几种方案，可以去github上自己阅读) 测试: 12$ docker-compose exec hive-server bash# /opt/hive/bin/beeline -u jdbc:hive2://localhost:10000 如果没有报错，说明hive已经成功运行了，尝试输入： 1&gt; CREATE TABLE pokes (foo INT, bar STRING); 创建表格，句末分号不要丢。 hbase hbase后续再更新]]></content>
      <categories>
        <category>日常瞎玩</category>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tricks]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%AD%97%E5%85%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[没有条理，看到就记录一下。 dict 迭代方法 使用dict.items同时迭代字典的KEY和内容。 12for name, value in dict.items(): …… dict.values()用来迭代字典的名字，但是python版本的问题导致values顺序不能保证，所以如果有明确对应需要的话，一定要用键值对的方式批量赋值。 直接迭代dict，得到的内容是一个一个的小字典： 12for d in dict: print(d["keyname"]) json json也是一种存储文件的形式，有几个比较常见的函数如json.dumps(),json.loads() 1234567x = &#123; "name":"John", "age":30, "city":"New York"&#125; # 这是一个字典的形式y = json.loads() # 得到的是一个python dictionaryz = json.dumps() # 得到的是Json string python的迭代器iter()和next() 123456mytuple = ("apple", "banana", "cherry")myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit)) 这样一波操作可以把里面的所有元素都打印一遍。 numpy numpy的slice的改变是会改变原有的内容的。 pandas pd.qcut(x, q, labels=None, retbins=False, precision=3, duplicates='raise')返回按照顺序分割好的区 sklearn 机器学习方向 标签转换 sklearn.preprocessing.OneHotEncoder()以及sklearn.preprocessing.LabelEncoder() LabelEncoder底下有一个fit_transform超级好用！ 1dataset['Sex_Code'] = label.fit_transform(dataset['Sex']) 这个东西搭配pandas的pd.get_dummies食用效果更佳 结果输出和比较 sklearn.metrics metrics.accuracy_score() metrics.confusion_matrix(y_true, y_pred, labels=None, sample_weight=None)用来计算混淆矩阵，但是要画出来还是需要一点点的加工。 现在还可以用voting来进行集成。一般来说，用很多的分类器，最后使用voting来打比赛会更合适。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Pyhton（五）-二叉树和树]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E4%BA%94%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树也是一些基本元素的汇集，树形结构也是由结点和结点之间的连接关系构成的，但是其结构和线性结构表不同，最重要的特征有： 如果一个结构不空，则其中存在着唯一的起始结点，称为“树根”。 按结构的连接关系，树根外的其余结点都有且只有一个前驱，但它可以有0个或者多个后继。并且在非空的树结构中一定有些结点并不连接到其他结点。 结构里的所有结点都在树根结点通过后继关系可达的结点集合里。即从树根结点出发，若干次后继关系可以到达结构中的任何一个结点。 结点之间的联系不会形成循环关系 这种结构里的任意两个不同节点出发，通过后继关系可达的两个结点集合，或者互不相较，或者一个集合是另外一个集合的子集。 本章重点： 利用堆结构实现优先队列 哈夫曼树 二叉树： 概念：二叉树是一种树形结构，它的每个结点至多关联到两个后继结点，即它的关联结点数可以为0，1或者2；另外，一个结点关联的后继结点明确地区分左右，或者为左关联结点，或者为右关联结点。 概念和性质 定义 二叉树是结点的有穷集合，这个集合或者是空集，或者是其中有一个称为“根节点”的特殊结点，其他结点分属两棵不相交的二叉树。这两棵二叉树分别是原二叉树的左子树和右子树。 几个基本概念 不包含任何结点的二叉树称为 空树。只包含一个结点的二叉树是一课 单点树。 父节点&amp;子节点 结点的子结点个数称为该结点的度数。二叉树树叶结点的度数为0，分支结点的度数为1或者2； 路径、结点的层和树的高度 一课二叉树的高度（也称为深度）就是树中结点的最大层数（即这棵树里的最长路径的长度）。树的高度是二叉树的整体性质，只有根节点的树高度为0，一般不讨论空树的高度。 二叉树的性质 二叉树最重要的性质就是： 树的高度和树中可以容纳的最大结点个数之间的关系。树的高度类似于表长，是从根结点（首结点）到其他结点的最大距离。 性质1：在非空二叉树第i层中至多有2i2^i2​i​​个结点 性质2：高度为h的二叉树至多有2h+1−12^{h+1}-12​h+1​​−1个结点（h≤0h \leq 0h≤0）（把每层结点个数加起来就好啦~~） 性质3：对于任何非空二叉树T，如果其中叶结点的个数n0n_0n​0​​，度数为2的结点个数是n2n_2n​2​​，那么n0=n2+1n_0 = n_2 + 1n​0​​=n​2​​+1 满二叉树和扩充二叉树 满二叉树：如果二叉树里的所有分支结点的度数都是2，则称它为一棵满二叉树。 满二叉树是一般二叉树的一个子集； 性质4：满二叉树里的叶结点比分支结点多一个。（根据性质3的推论） 扩充二叉树：对二叉树T，加入足够多的新叶结点，使T的原有结点都变成度数为2的分支结点，得到的二叉树称为T的扩充二叉树。扩充二叉树中新增的结点称为其外部结点，原树T的结点称为其内部结点。空树的扩充二叉树规定为空树。 性质5：扩充二叉树的外部路径长度EEE是从树根到树中各外部结点的路径长度之和，内部路径III长度是从树根到树中各内部结点的路径长度之和。如果该树有n个内部结点，那么E=I+2×nE = I+2 \times nE=I+2×n 完全二叉树 对于一棵高度为h的二叉树，如果其第0层到第h-1层的结点都满了，则所有结点在最左边连续排列，空位都在右边，这样的二叉树就是一棵完全二叉树。 性质6：n个结点的完全二叉树高度h=[log2n]h = [log_2n]h=[log​2​​n]，即不大于log2nlog_2nlog​2​​n的最大整数。 性质7：如果有n个结点的完全二叉树的结点按层次并按从左到右的顺序从0开始编号，对任意结点i(0≤i≤n−1)i(0 \leq i \leq n-1)i(0≤i≤n−1)都有： 序号为0的结点是根 对于i&gt;0,其父节点的编号是(i−1)/2(i-1)/2(i−1)/2 若2×i+1&lt;n2 \times i + 1 &lt; n2×i+1&lt;n，则它的子结点序号为2×i+12 \times i + 12×i+1，否则他没有左子结点； 若2×i+2&lt;n2 \times i + 2 &lt; n2×i+2&lt;n，其右子结点序号为2×i+22 \times i + 22×i+2，否则它没有右子结点。 通过性质7，可以方便的存入一个表或者数组，直接根据元素下标就能找到一个结点的子结点或者父节点。 根据性质1，二叉树的第i层有2i2^i2​i​​个结点，根据性质2，前i−1i-1i−1层结点如果全满的话，共计有2i−12^i - 12​i​​−1个。由于根的下标是0，第i层元素从下标2i−12^i - 12​i​​−1的位置开始存放，连续2i2^i2​i​​个元素属于这一层。 这说明，从完全二叉树到线性结构有自然的双向映射，可以方便地从相应线性结构恢复完全二叉树。但是，一般二叉树就没有这种性质。 一般而言，对于n个结点的二叉树有如下情况（直观的看法）： 如果它“丰满且整齐”，即树中很少度数为1的分支结点，且最长路径的长度差不多。则树中最长路径的长度将为O(logn)O(\log n)O(logn) 如果它比较“畸形”，最长路径的长度可能到达O(n)O(n)O(n) 抽象数据类型 1234567891011ADT BinTree: BinTree(self, data, left, right) is_empty(self) num_nodes(self) #求二叉树的结点个数 data(self) # 获得二叉树根存储的数据 left(self) # 获得二叉树的左子树 right(self) # 获得二叉树的右子树 set_left(self, btree) #用btree去掉原来的左子树 set_right(self, btree) #用btree 代替原来的右子树 traversal(self) #遍历二叉树中各节点数据的迭代器 forall(self,op) # 对二叉树中的每个结点的数据执行操作op 遍历二叉树 每棵二叉树有唯一的根节点，从而将其看做这棵二叉树的唯一标识。 系统化遍历二叉树有多种可能的方式，有两种基本方式： 深度优先遍历：顺着一条路径尽可能向前探索，必要时回溯。二叉树里最基本的回溯情况是检查完一个叶结点，无路可走时回头； 宽度优先遍历：在所有路径上齐头并进。 深度优先遍历 按深度优先方式遍历一棵二叉树，需要做的事情是：遍历左子树，遍历右子树和访问根节点。分别用L/R/D表示这三项工作。 不同的处理顺序： 先根序遍历（DLR顺序），得到序列称为“先根序列” 中根序遍历（LDR顺序），也称对称序。得到的序列称为“对称序列” 后根序遍历（LRD顺序），得到的序列称为“后根序列” 由于二叉树的子树也是二叉树，所以一种具体的遍历顺序可以继续被运用到子树的遍历中，就形成了一种遍历二叉树的统一方法。 在遍历过程中遇到子树为空的情况，就立即结束处理并转去继续做下一步工作。例如，在先根序遍历中遇到左子树为空，就转去遍历相应的右子树。 宽度优先遍历： 宽度优先遍历没有办法写成一个递归过程。 二叉树的list实现 python的list或tuple都可以用来组合成这样的三个元素，两者的差异仅在于变动性。 设计和实现 基于list类型很容易实现二叉树，采用如下设计： 空树使用None来表示 非空二叉树用包含三个元素的表{d,l,r}表示，其中： d表示存在根节点的元素 l和r是两棵子树，采用与整个二叉树相同结构的list表示。 显然，这样做是把二叉树映射到了一种分层的list结构，每棵二叉树都有与之对应的递归结构的list。比如，我们可以把一课二叉树用list表示为： 12345["A",["B",None, None], ["C",["D",["F", None，None], ["G",None, None]], ["E",["I",None, None], ["H",None, None]]] 比如，我们可以给出下面几个基本操作： 1234567891011121314151617181920def BinTree(data,left = None,right = None): return [data, left, right]def is_empty_BinTree(btree): return btree is Nonedef left(btree): return btree[1]def right(btree): return btree[2]def set_root(btree, data): btree[0] = datadef set_left(btree, left): btree[1] = datadef set_right(btree, right): btree[2] = data 用这套函数进行递归调用，可以改出很复杂的二叉树，例如： t1 = BinTree(2, BinTree(4),BinTree(8)) 另外，也可以对这个东西进行修改： set_left(left(t1), BinTree(5)) 二叉树的简单应用：表达式树 二元表达式&amp;二叉树 基本运算对象作为叶结点 运算符作为分支结点 表达式一旦生成，就不会改变，所以采用“不变形式”的tuple进行计算会比较方便。 1234567891011def make_sum(a, b): return ('+', a,b)def make_prod(a, b): return("*", a, b)def make_diff(a, b)； return('-', a, b)def make_div(a, b): return('/', a, b) 这样可以用上面定义的内容构造一个简单的表达式： el = make_prod(3, make_sum(2, 5)) 另外，在处理表达式的时候，还需要注意区别基本表达式（一个数字或者变量）和复合表达式（一个包含运算符号的元组）。 123456# 判断是否是基本表达式def is_basic_exp(a): return not isinstance(a, tuple)# 判断是否是数值def is_number(x)； return(isinstance(x, int) or instance(x, float) or isinstance(x, complex)) 表达式的求值 首先根据数学，有下面表达式的求值规则： 数和变量的值就是他们自身； 表达式根据运算符的情况处理，可以定义专门的处理函数； 如果一个运算符的两个运算符的情况处理，可以定义专门的处理函数。 123456789101112131415def eval_exp(e): if is_basic_exp(e)； return e op, a, b = e[0],eval_exp(e[1], eval_exp[2]) if op == "+": return eval_sum(a, b) elif op == "-": return eval_diff(a, b) elif op == "*": return eval_prod(a, b) elif op == "/": return eval_div(a, b) else: raise ValueError("Unknown operator:", op) 接下来还可以给出对和式和除式求职的函数。 123456789101112131415161718def eval_sum(a, b): if is_number(a) and is_number(b): return a + b if is_number(a) and a == 0: return b if is_number(b) and b == 0: return a return make_sum(a, b)# 定义除法def eval_div(a, b): if is_number(b) and b == 0: raise ZeroDivisonError if is_number(a) and is_number(b): return a/b if is_number(b) and b == 1: return a if is_number(a) and a == 0: return 0 优先队列 这里再介绍另一种缓存结构：优先队列与栈和队列相似，可以将数据元素保存在其中。 优先队列基于线性表的实现 树形结构和堆 线性和树形结构 由于按序插入操作效率低（要沿着表顺序检索插入位置），只要按照优先级顺序线性排列，就无法避免线性复杂性问题。 堆及其性质 采用属性结构实现优先队列的一种有效技术称为 堆。从结构上看，堆是结点里存储数据的完全二叉树。并且有特殊的堆序：任何一个结点里存储的数据（按所考虑的序）先于或者等于其子结点（如果存在）里的数据。 根据堆的定义，有： 在一个堆中，从树根到任何一个叶结点的路径上，各结点里所存的数据按规定的优先关系（非严格）递减； 堆顶一定是堆中最优先的元素（所以获取成本很低） 树中不同路径上的元素，不关心他们之间的顺序关系； 【注】 由于二叉树和连续表的形式可以一一对应，所以在表达的时候，把二叉树写成线性表的形式也是可以的，二者可以通过下标一一对应。 优先队列的堆实现 插入元素和向上筛选 解决堆插入和删除的关键操作称为“筛选”，分为向上筛选和向下筛选。 向上筛选 用新加入的元素（设为e）与其父结点进行比较，如果e较小就交换两个元素的位置，从而元素e可以不断上移。由于比较和交换的次数不会超过二叉树中最长路径的长度，所以根据完全二叉树的性质，加入元素的操作可以在O(logn)O(\log n)O(logn)的时间内完成 弹出元素和向下筛选 弹出：堆顶元素 弹出堆顶后的元素不再是堆，但是它的两个子堆依然是堆，如果取出原堆的最后一个元素填补到堆顶，就可以把它做成一棵完全二叉树。除了堆顶元素不满足堆序，其他元素依然满足堆序。从这样的二叉树结构恢复堆结构的操作叫向下筛选。 假设堆顶元素e和两个子堆的堆顶A，B。具体操作可以通过类似于“递归”的思想实现： 将e和A,B做比较，最小者作为堆顶；e和其中的最小者交换顺序 接下来的操作就和之前的操作一样，规模更小。 如果某次比较中，e已经是最小元素，则堆已经成立 如果e已经到底层，则堆也成立。 向下筛选的操作也是O(logn)O(\log n)O(logn)的操作，其长度不会超过树的最大高度。 堆的应用：堆排序 基于堆的优先队列的实现以及堆排序 应用：离散事件模拟 被模拟系统可以抽象为一些离散事件的发生，所发生的事件可以引发新的事件。（马尔科夫链？？） 模拟系统的特点： 系统中不断发生一些事件 一个事件在某个时刻发生，那它的发生有可能导致其他事件在未来发生。 【具体实现】一个负责检查过境车辆的海关检查站，notebook 车辆按一定时间间隔到达，间隔有随机性，范围为[a,b]分钟 不同车辆的检查时间也不同，随机分布在[c,d]之间。 海关可以开k个通道 目的： 希望可以研究出不同的通道数量对车辆通行的影响，以及每辆车辆的平均等待时间和通过检查站的平均时间。 二叉树的类实现 上面几种方法是基于list或者tuple，对二叉树的一些应用。 接下的这种二叉树实现方法称为“链接实现”，用数据单元表示一个二叉树结点，通过子结点链接（指针）建立结点之间的联系。采用这种表示方法，只要知道了一棵二叉树的根节点，就掌握了整个二叉树。 二叉树结点类 二叉树是由一组结点构成的，所以先定义一个表示二叉树结点的类。 12345class BinTNode: def __init__(self, dat, left = None, right = None): self.data = dat self.left = left self.right = right 二叉树类 基于二叉树结点类定义的二叉树类： 哈夫曼树 哈夫曼树（Huffman tree)是一种重要的二叉树，在信息领域有重要的理论和实际价值。 哈夫曼树和哈夫曼算法 根到其外部结点的路径长度之和： E=∑i=1mliE = \sum_{i=1}^{m}l_i E=​i=1​∑​m​​l​i​​ 其中mmm是扩充二叉树中外部结点的个数，lil_il​i​​是从根到外部结点iii的路径长度。 【定义】 在权为wl，w2，…，wn的n个叶子所构成的所有二叉树中，带权路径长度最小(即代价最小)的二叉树称为最优二叉树或哈夫曼树。 带权扩充二叉树的外部路径及其长度 给扩充二叉树的每个外部结点标一下数值，称为该结点的 权 ，表示与该叶有关的某种性质，进而定义 带权扩充二叉树 的外部路径长度为： WPL=∑i=1mwiliWPL = \sum_{i=1}^{m}w_il_i WPL=​i=1​∑​m​​w​i​​l​i​​ wiw_iw​i​​是外部结点的权。 注意这里的wiw_iw​i​​是一个集合而不是一个序列，集合中的实数集可以按照任意方式选取。 构造哈夫曼树的算法 从任意的实数集合构造出与之对应的哈夫曼树，描述如下： 算法的输入为实数集W={w_0,w_1,...,w_{m-1} 在构造中维护一个包含k棵二叉树的集合F，开始时k=mk=mk=m且F={T_0,T_1,…，T_{m-1}，其中每个TiT_iT​i​​是一棵只包含权为wiw_iw​i​​的根节点的单点二叉树。 算法过程中重复执行下面两个步骤，直到集合F中剩下一棵树为止； 构造一棵新二叉树，其左右子树是从集合F中选取的两棵权最小的二叉树，其根结点的权值设置为这两棵子树的根节点的权值之和。 将所选的两棵二叉树从F中删除，把新构造的二叉树加入F。 【注意】 构造中，有时会产生多重选择的情况，就会产生不同结构的哈夫曼树，但是它的外部路径的长度一定相等。 哈夫曼算法的实现 算法一开始应当建立起一组单结点的二叉树，以权值作为优先码存入优先队列，要求先取出队列里的最小元素。然后重复以下步骤，直至队列中只有一个元素： 优先队列里弹出两个权最小的元素（两棵二叉树） 基于所取的二叉树构造一棵新的二叉树，其权值取两棵子树的权值之和，并将新构造的二叉树压入优先队列。 还有两个必须解决的小问题： 需要为二叉树定义一个序，权值小的二叉树在前； 需要检查优先队列中的元素（二叉树）个数，以便在只剩一棵时结束 哈夫曼树的实现]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好难四儿啊]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%A5%BD%E9%9A%BE%E5%9B%9B%E5%84%BF%E5%95%8A%2F</url>
    <content type="text"><![CDATA[今儿在图书馆学习，学到了有关计算的前缀、中缀和后缀的内容。突然想到之前读过的一篇短篇科幻《好难四儿啊，那些鹁鸦鸲子》 这篇文章说的是思维定式。今天看到前缀后缀很明显会比中缀简单很多（因为不需要加上括号之类的辅助就可以把一个表达式写得清清楚楚），然而我读起来实在是吃力。可能这就是思维定式吧。 这是我鲜有意识到思维局限的情况，人往往都是愚蠢而不自知的。]]></content>
      <categories>
        <category>杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构Pyhton（四）-栈和队列.md]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-md%2F</url>
    <content type="text"><![CDATA[在常用的数据结构中，有一批结构被称为“容器”。一个容器结构里总包含一组其他类型的数据对象，称其为元素。 除了线性表以外，还有两种最常用的容器，称为栈（stack)和队列(queue)，他们都是使用最广泛的数据结构。 本章重点 栈和队列的定义 栈和递归 栈和队列的应用：迷宫求解问题 概述 栈：保证元素后进先出（Last In First Out,LIFO)，简称LIFO结构。 队列：保证元素先进先出（First In First Out) 栈（stack) 栈结构的顺序表实现 12345678910111213141516171819class SStack(): def __init__(self): # 用list对象_elem存储栈中元素 self._elems = [] # 所有栈操作都映射到list中 def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow("in SStack.top()") return self.elem[-1] # 后进先出，得到最后一个元素 def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow("in SStack.pop()") return self._elems.pop() # 以列表形式弹出 栈的链接表实现 以下是基于LNode链接表实现的。有关于LNode的定义见这篇文章 123456789101112131415161718192021class LStack(): # 基于链接表技术实现的栈类，用LNode作为结点 def __init__(self): self._top = None def is_empty(self): return self._top is None def top(self): if self._top is None: raise StackUnderflow("in LStack.top()") return self._top.elem def push(self, elem): self._top = LNode(elem, self._top) def pop(self): if self._top is None: raise StackUnderflow("in LStack pop()") p = self._top self._top = p.next return p.elem 栈的应用 算法或者程序里的辅助存储结构 后进先出的性质，保证特定的存取顺序。 颠倒一组的顺序 12345678#假设list1里存储这要颠倒的列表list1 = [1, 2, 3, 4, 5]st1 = SStack()for x in list1: st1.push(x)list2 = []while not st1.is_empty(): list2.append(st1.pop()) 括号匹配问题 逻辑： 检查文本，找出括号 找到的开括号，压进栈中 找到的闭括号和最近找到的开括号进行匹配； 成功则继续，不匹配则以失败结束。 代码实现： 1234567891011121314151617181920212223242526272829303132def check_parens(text): """ 括号匹配检查函数，text是被检查的正文串 """ parens = "()[]&#123;&#125;" open_parens = "([&#123;" opposite = &#123;")":"(", "]": "[", "&#125;": "&#123;"&#125; # 表示配对关系的字典 def parentheses(text): """括号生成器，每次调用返回text里的下一括号及其位置""" i, text_len = 0, len(text) while True: while i &lt; text_len and text[i] not in parens: i += 1 if i &gt;= text_len: return yield text[i], i print(text[i]) i += 1 st = SStack() # 保存括号的栈 for pr, i in parentheses(text): # 对text里各括号和位置进行迭代 if pr in open_parens: st.push(pr) # 如果是开括号，就押进栈 elif st.pop() != opposite[pr]: # 如果不匹配就失败 print("Unmatching is found at", i , "for", pr) return False else: pass # 因为成功了，就啥都不做 print("All parenthese are correctly matched") return True 表达式的表示、计算和变换 后缀表达式的计算： 生成一个判断对象类别的函数（是运算度还是运算对象？）nextItem() 如果是运算对象，存起来以备后续is_operated() 如果是运算符（假设都是二元运算符），则取得前面的对象或者已经运算得到的结果，进行计算并保存结果。 这就涉及到存储结构的问题。因为每次结果都不能直接使用，而是应当缓存起来，以备后续。 需要记录的是已经掌握的数据 每次处理运算符都应该用最后记录的几个结果（二元运算符就是2）。 给出算法框架如下： 123456789while 还有输入: x = nextItem() if is_operand(x): # 是运算对象，转换为浮点数并入栈 st.push(float(x)) else: a = st.pop() # 第二个运算对象 b = st.pop() # 第一个运算对象 … … 现在细化一下。 首先，应当定义一个函数，把输入的字符行分割成项。 12def suffix_exp_evaluator(line): return suf_exp_evaluator(line.split()) 其余更详细的还是戳这里 栈与递归 在一个数据结构里，某个或者某几个部分具有与整体相同的结构，就称之为这是一种递归结构。 例如，由结点通过链接构成的单链表，就是递归的实例。这种表或者为空，或者在其非空时，去掉第一个结点后剩下的结点链仍然具有相同的结构。 递归结构需要一个终结点，这个终结点应当是非递归的，由基本结构构成的部分。窦泽，就会出现无线递归，不能成为良好的定义。 结点链的空链接（None)就是递归的终点 阶乘函数的递归计算 12345def fact(n): if n == 0 : return 1 else: return n * fact(n-1) 这个递归计算是一个“后进先出”的实例。如果要计算fact(3)，则先把参数3压入栈；随后执行调用fact(2)，把参数2压入栈。知道执行fact(0)得到结果1后，先和参数2相乘，再和参数3相乘，从而是一个典型的“后进先出”实例。 递归/函数调用 如果要支持递归定义函数的实现，就需要一个栈来保存递归函数执行时每一层调用的局部信息，留着函数调用返回后继续使用。 函数调用也是一样的，都是“后调用先返回”思想。 递归与非递归的对应 摸清楚里面的结构之后，可以自己管理栈来模拟函数的调用过程，比如下面的实现。 123456789def norec_fact(n): # 自己管理栈来模拟函数的调用过程 res = 1 st = SStack() while n &gt; 0: st.push(n) n -= 1 while not st.is_empty(): res *= st.pop() return res 递归函数与非递归函数 与此对应的，任何一个包含循环的程序都可以翻译为一个不包含循环的递归函数。 不过作者也说了，因为现在大部分调用函数的效率损失是可以接受的，所以大部分情况下可以不考虑，只有一些特殊的情况需要做这种工作。 栈的应用：简单背包问题 背包里可以放入重量为weightweightweight的物品，现在有nnn件物品的集合SSS，其中物品的重量分别为w0,w1,...,wn1w_0, w_1,...,w_{n_1}w​0​​,w​1​​,...,w​n​1​​​​，问题是喜爱你在能否从中选出若干件物品，使其重量之和刚好等于weightweightweight，存在则有解，否则无解。 现在考虑问题的求解：用记法knap(weight, n)表示n件物品相对于总重量weightweightweight的背包问题。考虑一件物品的选/不选，把问题划分为两种情况： 不选最后一件物品，那么knap(weight,n−1)knap(weight, n-1)knap(weight,n−1)的解就是knap(weight,n)knap(weight, n)knap(weight,n)的解，找到前者的解就是找到后者的解。 若选择最后意见物品，则如果knap(weight−wn−1,n−1)knap(weight-w_{n-1}, n-1)knap(weight−w​n−1​​,n−1)有解，其解再加上最后一件物品就是knap(weight,n)knap(weight, n)knap(weight,n)的解，即前者有解，后者就有解。 这说明，我们可以把背包问题归结为两个子问题。第一类情况下，总重量不变但是物品数量-1；第二种情况，总重量减少，物品数量也减少。只要任何一个子问题有解，这个问题就应当有解。 最后，我们可以把这个问题归结为最简单的三种情况： 总重量为0，这说明有解 总重量小于0，因为在递归的过程中，重量总是递减的，有可能出现这种情况，这说明目前已有的安排不能满足条件 总重量大于0但是没有物品可以用了，说明这个问题无解。 所以我们按照上述分析可以实现以下的代码： 1234567891011def knap_rec(weight, wlist, n): if weight == 0: return True if weight &lt; 0 or (weight &gt; 0 and n &lt; 1): return False if knap_rec(weight - wlist[n-1], wlist, n-1): # 子问题1 print("Item" + str(n) + ":", wlist[n-1]) return True if knap_rec(weight, wlist, n-1): # 子问题2 return True else: return False 队列 队列(queue)，又被称为队，也是一种容器，可以存入元素、访问元素或者删除元素。 队列抽象数据类型 123456ADT Queue: Queue (self) # 创建空队列 is_empty(self) # 判断队列是否为空，为空时，返回True；否则返回false enqueue(self, elem) # 将元素elem入队 dequeue(self) 删除队列里最早进入的元素并返回其值，称为出队 peek(self) # 查看队列里最早进入的元素，不删除 链接表技术的队列实现：采用带表尾指针的单链表。它支持O（1）时间的表尾插入以及表首的访问和删除。 队列的顺序表实现：循环顺序表 队列使用时，顺序表的开始位置不改变； 队头变量q.head记录当前队列里的第一个元素的位置；队尾变量q.rear记录当前队列里最后元素之后的第一个空位。 队列元素保持在顺序表的一段连续单元中，即[q.head:q.rear] 出队和入队操作需要更新变量q.head和q.rear，正确更新操作如下： 12q.head = (q.head + 1) % q.lenq.rear = (q.rear + 1) % 1.len 注意这里的值是用来更新变量q.head和q.rear的指针位置的。 另外，队列状态也需要判断。循环顺序表性质决定了它可以存储的数据量是固定的。当表满的时候会出现q.head = q.rear，这和表空的形式是是一样的，从而不能区分。我们这里需要另外定义一个表满的情况。即(q.rear + 1)%q.len = q.head，而采用这种方法会导致表中出现一个多余的空位。 队列的list实现 look here 迷宫问题的求解和状态空间搜索 我们这里考虑二维平面的迷宫问题。 表示方式 采用0/1形式来表示迷宫。0表示通路，1表示封闭点 对于其中的某一个格子，如果它的方位是(i,j)，则他四周的方位则表示为这个二元组分别加上后面这些：dirs = [(0,1),(1,0),(0,-1),(-1,0)]。 关于问题的定义 为防止在局部上绕圈，找过的位置改为2，这样判断时只要判断其位置是否为0即可。 如果一个位置有多个方向可以选择，按照上述的形式找出位置后，只需要执行一个简单的循环，遍历可能的路径即可。 具体的实现过程look here 基于栈和队列的搜索过程 栈和队列的搜索过程的区别在哪里呢？~ 以迷宫为例，栈是深度搜索（会把一条路径都搜索完，直到思路为止）；而队列是宽度搜索（会搜索每一条路径的相同长度）。 深度和宽度优先搜索的性质： 能否保证找到解？ 深度：如果有无求多的子空间，则有可能卡在某一子空间上，找不到解； 宽度：只要存在有穷长路径，就能找到解，而且找到的一定是最短路径（最短解） 找到解如何得到相应路径？ 栈：保存在栈中的就是相应路径 队列：需要单独做一个对应的字典来保存前述位置，但是这样对于状态空间很大的解来说需要的存储空间太大了，不是很友好。 搜索所有可能的解和最优解？ 栈：深度搜索必须要穷举所有的解后才能得到最优解，状态空间很大时不能成立 队列： 不需要穷举，第一个获得的解就一定是最优解 搜索的时间开销和空间开销？ 对于栈和队列而言，探查位置的开销都是O（1），所以主要开销在空间开销上。 栈的空间开销：搜索过的最长路径。 队列：主要是由分支最多的那一层决定的；此外为了得到路径还需要额外的存储。开销也可能很大。 总结：一个问题可以用空间搜索的方式解决的话，栈和队列还是各有优势，主要还是考虑他们的空间开销和需要找到几个最优解来确定最终的解决方案。 几点补充 几种与栈或者队列相关的结构 双端队列：允许两端插入和删除元素；因此功能覆盖上面的所有结构。 python的deque类 ……]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（三）-字符串]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本章重点 KMP算法 python的正则表达式 re的匹配对象（match） 字符集、字符串和字符串操作 由于字符串处理的需要，要求字符集上有一种确定的序关系，称为字符序。故而，对于字符集中任意两个字符，&lt;, =, &gt;三种关系之一成立。 字符串可以被看为是一种特殊的线性表，但是由于字符串有很多自身特殊的处理方式，所以经常会把字符串作为一个整体使用和处理，考虑许多以整个串作为你对象的操作。 字符串的相关概念。 字符串的长度 字符在字符串中的位置 字符串相等(长度和字符) 字典序：字典序是字符串上的一种序关系。从左向右查看的两个串中下标相同的各对字符，遇到的第一对不同字符的字符串决定了这两个字符串的顺序。abc &lt; abd, 且abc &lt; abcd。 字符串拼接 子串关系 前缀和后缀：若存在s1=s2+s′s_1 = s_2 + s&#x27;s​1​​=s​2​​+s​′​​，则称s1s_1s​1​​为s2s_2s​2​​的一个前缀。后缀同理。s的开头/结尾的任何一个子串都是它的前缀/后缀。空串和s既是s的前缀，也是s的后缀。 字符串的实现 在实现字符串时，需要考虑两个问题 字符串的存储：全部放在一起存储太占空间，而一个一个存储需要很多链接域，额外开销大，故而实际中，可以折中，将字符串分段保存在一组存储块里，并链接起这些存储块。 串结束的表示：①用数据域记录编码长度。②用特殊编码表示结束。 字符串匹配（子串查找） wiki网页：字符串搜索 朴素的串匹配算法 123456789101112def naive_matching(t, p): #查找t中是否有子串p m, n = len(p), len(t) i, j = 0, 0 while i &lt; m and j &lt; n: # 当i == m时找到了匹配 if p[i] == t[j]: # 该字符匹配，进行下一位的匹配 i += 1 j += 1 else: i, j = 0, j - i + 1 # 该字符不匹配，故而从字符串的下一位开始继续匹配。（ if i == m: # 找到了匹配的子串，返回其起始下标 return j - i return -1 # 无匹配，就返回特殊值 其中，j-i+1就是考虑的从字符串上次开始的下一位开始匹配。 该算法的最坏情况是每次都在最后一位匹配失败，需要匹配m×(n−m+1)m\times (n-m+1)m×(n−m+1)次，所以算法复杂度为m*n。 无回溯串匹配算法（KMP算法） KPM算法的分析 基本思想是对于已经匹配过的元素无回溯。 如果模式串pip_ip​i​​和某个tjt_jt​j​​匹配失败了，下一步是找一个ki(1&lt;ki&lt;m)k_i(1 &lt; k_i &lt; m)k​i​​(1&lt;k​i​​&lt;m)，将模式串后移若干位，匹配pkip_{k_i}p​k​i​​​​和tjt_jt​j​​。 问题的关键就是如何确定kik_ik​i​​。实际上，对于模式串中的每一个元素i,都应该有一个确定的kik_ik​i​​和它一一对应。通过对模式串本身的分析，得到相应的kik_ik​i​​并存储起在pnext[i]表中。 有一种特殊情况是，某pip_ip​i​​匹配失败后，发现之前做过的匹配都没有价值，则下一步就需要从头开始，用p0p_0p​0​​和tj−i+1t_{j-i+1}t​j−i+1​​比较1。针对这种情况，取pnext[i] = -1 KPM算法的实现 假设已经做出了pnext表，以下考虑KMP算法的实现： 注意这里有两个指针，指针i指向匹配串p,指针j指向被匹配串t。 1234567while j &lt; n and i &lt; m: # i == m 说明找到了匹配 if i == -1: # 遇到-1的话匹配下一对字符，j和i同时往后挪。 j, i = j + 1, i + 1 elif t[j] == p[i] # 如果相等，就再比较下一对字符，j和i也同时往后挪。 j, i = j+1, i+1 else: i = pnext[i] # 取第i个字符的 其中，if语句中的两个分支可以合并，有： 12345678910111213# 核心循环步骤def matching_KMP(t, p, pnext): '''KMP串匹配，主函数 ''' j ,i = 0, 0 n, m = len(t), len(p) while j &lt; n and i &lt; m: if i == -1 or p[i] == t[j]: j, i = j + 1, i + 1 else: i = pnext[i] if i == m: return j-i return -1 构造pnext表：分析 如果在位置i匹配失败，那么位置i对应的pnext[i]这个位置应该满足两个条件： 选择的该位置的前缀子串，应该和i前相同长度的子串一致 如果满足上述条件的位置不止一个，则应该移动最短距离，以防止有匹配的遗漏。 实际上，经过一波分析，问题被转化成为：寻找匹配串p中，前i个位置的最长的相同的前缀和后缀。k就是它们的长度，只有这样才能保证不会跳过可能的匹配。 以下是设计出的巧妙算法： 若已经对pnext[i-1]计算出结果为k-1,再比较p[i]和p[k]，有两种情况： 如果pi=pkp_i = p_kp​i​​=p​k​​,说明对于i的最长相等前后缀的长度，比对i-1的最长相等前后缀的长度多1，由此，应该把pnext[i]设置为k，然后考虑下一字符。 否则，应该把p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀拿来做检查。（注意这里只是检查而没有设置，因为p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀也是p0...pi−1p_0...p_{i-1}p​0​​...p​i−1​​的某一个相等前缀（不一定是最长的），所以可以拿来做检查。 如果是已知pnext[0]=-1和直至pnext[i-1]的已有值求pnext[i]的算法： 假设pnext[i-1]=k-1,如果pi=pkp_i=p_kp​i​​=p​k​​，那么p0...pip_0...p_{i}p​0​​...p​i​​的最长相等前后缀的长度就为k，设置pnext[i]=k，将i+1后继续循环； 如果pi≠pkp_i \ne p_kp​i​​≠p​k​​，则设置k = pnext[k]（转去考虑前一个更短的，又能保证匹配的前缀）； 若k=−1k=-1k=−1（等于-1是从第二步pnext来的），则p0...p1p_0...p_1p​0​​...p​1​​的最长相等前缀的长度就是0，设置pnext[i]=02,然后将i+1后继续递推。 这里k就是最长相等前缀个数，它也是一个指针 KMP算法的时间复杂度是O（m+n）. 字符串匹配问题 串匹配、搜索的不同需要 人们需要查找的是具有某种形式的字符串。&lt;\font color = gray&gt;（比如re包里的正则匹配？）&lt;\font&gt; 通配符：比如*，与任意一串字符串匹配；?，与任何一个实际字符匹配。 正则表达式（Regular Expression）。 Python的正则表达式语言 基本情况 原始字符串 在普通字符串前加上“r”或者“R”，内部的“\”不进行转义。 元字符（特殊字符） 共14个，这些元字符起着特殊的作用： $ . ^ * + ? \ | { } [ ] ( )$ 主要操作 字符操作 生成正则表达式对象：re.compile(&lt;正则表达式&gt;) r1 = re.compile(&quot;abc:) 这样做的好处是可以避免重复生成正则表达式 检索：re.search(&lt;正则表达式&gt;, &lt;字符串&gt;) 若找到，则返回一个match类型的对象。否则，返回None。match类型的对象还可以被作真值直接进行逻辑判断。 匹配：re.match(&lt;正则表达式pattern&gt;, &lt;字符串string&gt;) 检查string是否存在和pattern匹配的前缀，如果找到则返回一个match类型的对象；否则返回None。match对象里记录的是成功匹配的相关信息。 例如： 12re.search(r1,'aaabcbcbabcb') # 将匹配成功re.match(r1, 'aaabcbcbabcb') # 将匹配失败 分割：re.split(pattern, string, maxsplit, flag = 0) 12345re.split(' ', "aaa bbb abc are not the same")&gt;&gt;&gt; ['aaa', 'bbb', 'abc', 'are', 'not', 'the', 'same']re.split[" ", "a b c d"]&gt;&gt;&gt; ['a', 'b', '', 'c', '', '', 'd'] #得到几个空串 找出所有匹配串：re.findall(pattern, string, flags = 0) 字符组 字符组形式：[……]，其中的元素顺序不重要。它会和字符组中的任何一个字符串匹配，称为字符组描述。例如，[abc]可以和a或b或c进行匹配。 区间形式：【0-9][a-z],它还可以和字符列表混写，比如[34ad-fs-z] 特殊形式[……]它表示的是对于之后列出的字符组求补。即这种字符组表达式与所有没有列在括号里的字符串匹配。比如，[0-9]匹配非十进制数字的所有字符。 注意如果需要在字符组里包含&quot;[]“或者“^”，则都应该在前面加上&quot;\”进行转义。 圆点字符(.)，这是一个能匹配任何字符的通配符。 例如，模式串a…b匹配所有以a开头b结尾的四字字符。 例如，p\w\w\w可以和p开头随后为任意三个字母数字的串进行匹配。 重复描述符（*） 例如，模式a*要求匹配模式a能匹配字符串的0次或者任意多次重复。re.split('[ ,]*, s)可以把按照任意多个空格或者,来分割s。 在考量重复匹配时，如果有多个子串满足条件，有两种匹配方式： 贪婪匹配：匹配最长子串 非贪婪匹配（吝啬匹配）：模式有可能匹配的最短子串。 此外，“+”表示至少一次匹配。 可选描述符 “a?&quot;表示和a的0或1次重复匹配。 重复次数描述符 a{n}表示和a匹配的串的n次重复匹配。 重复次数范围描述符 a{m, n},a{,n}(等价于a{m,n})，a{m,}等价于a{m, infinity} 注意*、+、？、{m,n}都采用贪婪匹配规则。 非贪婪匹配描述符： *？，+？，？？，{m,n}?采用的都是非贪婪匹配策略。 选择 选择描述符：|，它的结合力是最弱的，比顺序组合的结合力还要弱。 首尾描述符 行首描述符：以“^&quot;符号开头的模式，只能与一行的前缀子串匹配。 12re.search('^for', "books for children") # 结果为Nonere.search("^for", "books \nofor children") # 匹配成功 行尾描述符：以&quot;$&quot;符号结尾的模式，与一样的后缀子串匹配。 12re.search("$fish", "cats like to eat fishes") # 结果为Nonere.search("$like", "cats like\neat fishes") # 匹配成功 匹配对象（match对象） 逻辑：match对象总表示逻辑为真，所以可以被用作逻辑判断 取得子串：mat.group() 在目标串里的匹配位置：mat.start() 取得mat代表的成功匹配在目标串里的实际匹配位置。 目标串中被匹配子串的结束位置：mat.end() 目标串里被匹配的区间：mat.span() 得到匹配的开始和结束位置形成的二元组。也就是说 1mat.span() == mat.start(), mat.end() 其他：mat.re和mat.string（这两个表达式是数据域访问，不是函数），分别取得这个match对象所做匹配的正则表达式对象和目标串。 模式里的组（group） 圆括号表示模式段中的一个组。使用mat.group(n)来调取与其中第n组匹配的字符串。mat.group(0)表示与整个模式匹配的字符串。 另外，match.groups将得到一个序对。 组的另外一个用途是，在匹配中应用前面的成功匹配。比如r&quot;(.{.{2}) \1可以匹配&quot;ok ok&quot;（两个字符，加一个空格，然后匹配相同的内容），不能匹配“oh no&quot; 其他匹配操作 re.fullmatch(pattern, string, flags = 0)，若整个string和pattern配对成功，返回match对象 re.finditer(pattern, string, flags = 0)，和findall类似，但是它会返回一个迭代器，顺序取得各非重叠匹配得到的match对象。 re.sub(pattern, repl, string, conut = 0, flags = 0)，生成替换结果的串。repl可以直接是一个字符串，也可以是一个以match对象为参数的函数。用其调用match对象的返回值来替换被匹配的子串。 正则表达式对象 re.compile(pattern)生成一个正则表达式对象。除了用来搜索外，它本身还支持另一组方法，功能也更强。以下用regex来表示一个正则表达式对象，它有这样一些方法： 检索：regex.search(string[,pos[,endpos]])，可以指定检索的开始和结束位置。 匹配：regex.match(string[,pos[,endpos]])，也可以指定匹配区间。 完全匹配：regex.fullmatch(string[,pos[,endpos]])，检查string中由指定范围构成的子串是否和regex匹配。 正则表达式的使用 如果目标串中存在一些（或者很多）与正则表达式匹配的子串，需要逐个处理，在这种情况下采用迭代器的方式最方便。编程模式是： 1234rel = re.compile(pattern)for mat in rel.finditer(text): ...mat.group()... # 取得被匹配的子串，做所需操作。 ... text[mat.start()]...text[mat.end()]... 不过这种写法有点繁琐，拿到这种字符串，先考虑能不能用re.sub进行处理，如果实在不行再用迭代器方案。 单词边界 \b描述单词边界。但是，python字符串中\b表示退格符，这两个重复了。有连个方法可以解决这个问题 模式串中的\双写。 模式串采用原始字符串的形式（加上r) python程序里的整数匹配可以写为：r'\b(0+|[1-9]\d*)\b' 若是希望匹配带有正负号的一般整数，可以写为：r'\b[+-]?(0+|[1-9]\d*)\b 补充 为了方便，re还提供了如下以转义串形式定义的常用字符组，包括： \d: [0-9] \D: [^0-9] \s: [ \t\v\n\f\r] 即与所有空白字符进行匹配 \S: [^ \t\v\n\f\r] 与所有非空白字符进行匹配 \w：[0-9a-zA-Z] \W：[^0-9a-zA-Z] 1.这里我觉得书中描述不清，应当是直接从上一次匹配的下一个进行匹配，所以应当是$t_{j-i+1}$而不是$t_{j+1}$开始匹配 ↩2.这个地方有一点奇怪，如果设置为0的话，-1是哪里来的…… ↩]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《道林·格雷的画像》摘抄]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近来疯狂迷恋王尔德。 书没有道德和不道德之分，只有写得好的和写得差的，仅此而已。 “哦，我也说不清楚。当我心有挚爱时，我绝不向任何人说出他们是谁，说出来就好比一点点出卖他们。我愈来愈喜爱隐秘了，这样似乎能使我们体会到现代生活的秘密和美妙。” 顺其自然才是一种姿态，而且是据我所知最令人恼火的姿态。 至于信不信的问题，只要不可信的，我都相信。 或者就敌意而言，何为敌意？你对人人都喜欢，也就是说，你对人人都漠然。 1 我交朋友，都是因为他们长得好看（哈哈哈哈哈）；我结识人，都是因为他们有好的性格；我选敌人，都是因为他们有智慧。 但无疑天赋比美貌更持久，这也是我们都拼命接受过多教育的原因。在疯狂的生存竞争中，我们都希望拥有某种持久不灭的东西，所以我们用垃圾和事实填满我们的思想，愚蠢地希望保持自己的地位。无所不知的人——这就是现代人的理想，而无所不知的人的思想让人感到恐怖。它就像一个小古董店，里面只有怪物和灰尘，一切都价过其实。 ——“世上没有‘好道德’这种东西，格雷先生。所有影响都是不道德的，从科学的角度看，都不道德。” ——“为什么？” ——“因为影响一个人，就是把自己的灵魂给他。他就不会依从自己的天性思考，或让自己天性的激情燃烧。他的美德不真的属于他。他的罪孽，要是有罪孽存在的话，也都是借来的。他成了别人音乐的一个回声，一个并非为他而写的剧本中的演员。生活的目的就是自我进步，要完全释放自己的天性——这是我们每个人来到人世的目的。现如今，人们竟怕起自己来了。他们忘记了自己的最高职责，即对自己应付的责任。 我相信，如果一个人能活得充分、彻底、表现出每一种感情，表达出每一种思想，实现每一种梦想——我相信，世界会获得如此新鲜的喜悦的冲动，会因此使我们忘掉中世纪时代的所有弊病，重回希腊的理想——可能是某种比希腊理想更美好，更富饶的东西。 只有感官才能拯救灵魂，就像只有灵魂才能拯救感官一样。 美是世上的一大客观存在，就像阳光、春光，或者我们称之为月亮的，银色贝壳般在水中的倒影，这是毋庸置疑的。 人有时会说美只是一种肤浅的东西。或许如此，但至少不会像思想一样肤浅。对我而言，美是奇迹中的奇迹。只有浅薄之人才不以貌取人。世界真正的神秘存在于可见之物，而非不可见之物。 啊！当你拥有青春时，你就要认识到它。不要虚掷你的黄金岁月，去听冗长乏味的说教，试图弥补无妄的失败，或把你的生命献给无知、庸常和低俗。 活着！活出你宝贵的内在生命。什么都不要错过，始终去寻找新的感受。无所畏惧…… 现在的人啊，什么东西的价格都知道，但它们的价值，都不知道。 男人结婚是因为厌倦，女人结婚是因为好奇，结果是双方都感到失望。 我不是在笑，道林，至少不是在笑你，但你不该说这是你一生中最浪漫的事。你应当说是你一生中的第一次浪漫。你会一直有人爱，你也会一直爱上爱，多情是无所事事者的特权，一生只爱一次的人才是真正的浅薄之人。他们自称忠实、忠诚，我则称之为习惯懒惰，或是缺乏想象。忠诚之于感情生活，就像惯性之于理智生活——都只是承认失败。忠诚！将来我一定要研究研究这个东西。其中包含着对财产的贪欲。如果不是因为害怕被别人捡走，我们肯定要扔掉很多东西。2 拿别人的悲苦做谈资，总归是及其卑微的。 人都爱放弃自己随需要的东西，这就是我所谓的慷慨的深意。 好的艺术家，都只存在于他们的作品之中，他们本人都是极其无聊乏味的。伟大的诗人，真正伟大的诗人，都是世间万物中最没有诗情画意的家伙。但蹩脚诗人，却绝对魅力四射。诗写得越拙劣的诗人，看上去却越动人。 但经验中没有驱动力。它与良心一样，都不是积极的动因。实际上它所能昭示的一切，无非是我们的未来与我们的过去一模一样，我们曾经带着厌恨犯下的罪孽，我们会带着愉悦一再犯下去。 现如今，任何事我都不说赞成还是不赞成。这种带着生活的态度是荒谬的。我们被送到人世间，不是为了宣扬我们的到的偏见的。 我们之所以都喜欢把别人往好处想，是因为我们都为自己感到害怕。乐观主义的基础就是纯粹的恐惧，我们称赞邻居拥有那些美德，就以为我们自己慷慨，实际上只是因为那些美德可能对我们有利。我们赞扬银行家，只为可以透支；我们找出拦路强盗的优点，只是希望他会饶过我们的口袋。我说的话都当真。我最鄙视乐观主义。至于说生活被毁，没有什么生活会被毁，只有生长被遏制才是真的毁了。如果你想破坏一个人的本性，你只需改造它。 “‘善’，就是要与自身和谐。”他用苍白尖细的手指碰了碰手中杯子的细柄，说，“不和谐，就是被迫与他人维持和谐。人自身的生活才是重要的，至于周围人的生活，假如有人想做道学先生或清教徒，他尽可抒发自己的道德观念，但不管别人的事。除此之外，个人主义其实抱有更崇高的目标。现代道德就体现在接受自己时代的标准。而我认为，对任何一个有教养的人而言，接受自己时代的标准就是一种最严重的不道德。” 陈年旧事的唯一魅力，在于它已成旧事。 我们生活在一个读书太多反而愚蠢的年代，一个思考太多反而不美的时代。 表达赋予事物真实存在。 “做过就做过了，过去的已经过去了。”“你称昨天是过去？”“这与时间的实际长短有什么关系？只有浅薄的人才需要数年来摆脱一桩感情。” 人天生害怕比自身强大的激情和感觉，他们意识到自己与低级生物有同样的欲望和感受。 当然，这种新享乐主义是服务于理智的，不接受任何形式的，以牺牲情感体验为代价的理论或体系。事实上，它的目的就是体验本身，而非体验的结果，不管这种结果是苦是甜。禁欲主义使感觉丧失，庸俗的纵情挥霍使感情迟钝，这与新享乐主义无关。它要教会人珍视生活的一个个瞬间，而生活本身就如同一个瞬间。 山风呜咽叹息着，盘旋在寂静的房子周围，似乎担心惊醒沉睡者，却又必须把睡神从紫色的山洞中唤醒。层层叠叠昏暗的薄纱揭开了，万物渐渐恢复了形状和颜色，我们看着黎明以它古老的方式重塑世界。暗淡的镜子又开始它映射事物的一天，数支熄灭的细蜡烛依旧立在原地，旁边摆着一本裁了一半的书、在舞会上戴的用金属丝扎着的花儿，或者一封不敢读或读了太多遍的信。在我们看来，似乎什么都没变。熟识的现实生活从虚幻的夜影里回来了，我们不得不从原来中断的地方重新开始生活，一种可怕的感觉悄然袭来，我们必须在一成不变、让人厌倦的陈规里葆有继续的力量。 与生活本身相比，他似乎觉得没有什么理论是举足轻重的。 社会——至少文明社会——从不会轻易相信任何对有钱又有魅力的人的诋毁。 人是一种具有多重生活、多层感觉、多种形式的复杂生物，人的精神秉承了思想和激情的奇怪遗产，人的肉体沾染上了祖先的可怕疾病。 人既有文学上的祖先，也有血缘上的祖先，可能很多人在类别和性情方面与文学上的祖先更接近，也更能明显地意识到。有时，道林似乎觉得，整个人类历史都只不过是自己生活的记录，不是它的实际生活，而是他想象中创造的生活，在他的脑海和激情里。道林觉得仿佛认识那些奇怪而可怕的历史人物，他们在世界舞台中登场，又离开，把罪孽变得如此神奇，把邪恶变得如此微妙。他仿佛觉得，他们的生活通过某种神秘的方式，变成了他的生活。 我们每个人身上都既有天堂又有地域。 它曾一度厌恶丑陋，因为丑陋让事物显得真实，而现在恰恰因为这个原因，他觉得丑陋可爱。丑陋是唯一的真实，粗鲁的争吵、可恶的贼窝、乱糟糟的生活中粗野的暴力、窃贼和流浪汉的肮脏……这些给人留下强烈真实的印象，比一切艺术的优雅表象和音乐的梦幻影子生动得多。 每个人都有自己的生活之道，也都会为此付出代价。唯一的遗憾是人不得不因为一次过错不停地付出代价。实际上，是一而再、再而三地偿还。命运与人做交易，从不结清账户。 我不怕死，我怕的是死亡的临近。可怕的死亡之翼似乎就盘桓在我周围沉闷厚重的空气中。 现如今，除了死亡，人可幸免于一切。 灵魂一种可怕的现实。可以买可以卖，可以交换，可以予以毒害，或完善。我们每个人内心都有一颗灵魂。 只要能恢复青春，我愿意做任何事，除了锻炼、早起和道貌岸然。 老年人的悲剧不在于老了，而在于还想年轻。 青春是什么？至多只是一段青葱、幼稚的时光，充满了浅陋的情绪和病态的思绪。为什么他要做青春的奴仆？青春已经把他毁了。 1.把这句话发给导师之后，她说“对人人都漠然”简直很你了。 ↩2.这简直是我看到现在对于占有欲最通透的解释！ ↩]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>王尔德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（二）-线性表]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本章重点 线性表的定义 顺序表和链接表 线性表的概念和表抽象数据结构类型 表的概念和性质 E中一组有穷个元素排成的序列。表中包含的元素的个数成为表的长度。元素之间的关系成为“下一个关系”，这是一种顺序关系，也称为线性关系，是一种线性结构。 线性表的操作 一个线性表可以提供的操作有： 创建线性表的操作； 获取表中信息的解析操作（判断是否为空） 动态改变表的内容； 表的组合操作（merge，subset……） 对表元素的遍历问题（给定对单个元素的操作，也存在可以对表进行的操作） 最后的这两类可以实现变动操作（直接在原表基础上修改）或者非变动操作（在原表基础上产生新表）。 线性表的实现 基本考虑： 考虑计算机内容的特点，还有保存元素和元素顺序信息的需要。 各种重要操作的消耗。比如is_empty这种，消耗越小越好。 两种实现模型 顺序表：表中元素顺序地存放在一大块连续的存储区里； 链接表：通过连接构造起来的一系列存储块里。 基本实现方式 表里保存的元素类型相同。 在顺序表中，可以通过Loc(ei)=Loc(e0)+c * i来计算出ei的位置。时间复杂度为O（1）。 元素类型（长度）不同 这个时候可以考虑将实际元素另外存储，而在顺序表里各单位位置保存相应位置的引用信息（链接）。 顺序表 基本操作的实现以及时间复杂度 创建和访问操作 简单判断（是否为空，大小）：O（1） 访问指定下标为i的元素：O（1） 遍历操作：给定一个i，然后每次+1（向下）或者-1（向上），时间复杂度为O（n） 查找给定元素d（第一次出现）的位置：检索/查找。 不改变结构的操作，有两种：直接访问，时间复杂度为O（1）；或者基于一个整型变量循环得到结果的，时间复杂度为O（n） 变动操作：加入元素 在尾端加入数据：O（1） 在第i个位置加入元素：有两种情况 不需要保持原来的相对位置：把i的元素移动到位置num。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 变动操作：删除元素 尾端删除：O（1） 在第i个位置删除元素：也有两种情况 不需要保持原来的相对位置：把num-1的元素移动到位置i。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 基于条件的删除：因为需要对元素进行遍历，故而时间复杂度也为O（n）。 顺序表的结构 顺序表可以用两种储存结构： 一体式结构：存储表信息的单元和元素存储区被安排在一块存储区里； 分离式结构：存储表信息的单元和元素存储区不被安排在一起，通过一个连接实现相连。 分离式结构扩容 替换元素存储区： 分离式结构的优势，可以在标识不变的情况下，为表对象换一块存储区。（可以改变表的容量）。 替换策略：容量加倍 每次更换存储区的时候，加倍容量:1,2,4,……。 这样算下来,总元素为n个时，时间复杂度为O（n），平均每个元素的时间复杂度为O（1）。 链接表 基本思想 表中的元素独立存储； 组成表结构的任一结点可以找到与其相关的下一结点； 前一节点中，用链接的方式显式地记录与下一结点之间的关联。 单链表 结点为二元组，表元素域中保存折作为表元素的数据项以及同一个表里下一个结点的标识。以下定义一个结点类 1234class LNode: def __init__(self,elem, next_ = None): self.elem = elem self.next = next_ 基本链表操作 创建空列表 删除链表 判断表是否为空 判断表是否满 加入元素 表首端插入： 123q = LNode(13)q.next = head.nexthead = q 一般情况的元素插入 创建新结点q并存入数据； 把pre所指结点next域的值存入新结点q的链接域next. 把pre结点的next域改为q 123q = LNode(15)q.next = pre.nextpre.next = q 删除元素 删除表首元素：更改表头指针，将其指向下一个结点即可。 1head = head.next 一般情况的元素删除：一般情况要先找到pre结点，将其next域指向被删结点的下一结点即可。 1pre.next = pre.next.next 扫描、定位和遍历 扫描 已知信息只有表头，故而只能从表头开始往下扫描： 1234p = headwhile p is not None and &lt;其他条件&gt;: &lt;对p进行操作&gt; p = p.next 后续为Python代码的实现，详细可以点击这里 两个链表的操作 链表翻转 python list类的reverse操作，可以实现两个元素互换。 *注意：如果使用单链表，则耗时会是O（n^2) 链表排序 python中的list对象有一个sort方法，可以实现排序。 单链表排序的实现过程。 从第1个元素开始循环，取出第i个元素。假设i前面的j个元素已经排好序了。 将i元素和j元素一一比较。如果第j个元素比i大，则将其右移一位； 直到找到比i小的元素为止，将i插入该空位。 以下为实现方法： 12345678def list_sort(lst): for i in range(1, len(lst)): #假设开始时[0:1]已经排序 x = lst[i] j = i while j &gt; 0 and lst[j-1] &gt; x: lst[j] = lst[j-1] j -= 1 lst[j] = x 单链表实现方法见笔记 总结 几种类型的表 基本单链表支持O（1）时间的前端插入&amp;删除工作；而定位和删除尾端都市O（n）时间 增加尾结点的单链表支持O（1）时间的首端/尾端插入和首端弹出，但不支持高效尾端删除; 循环单链表支持高效的首端/尾端插入和首端删除，但要注意结束条件； 双链表支持高效的首端/尾端删除和输入。 链接表的优点 表结构容易修改和调整 不需要修改结点的数据元素 方便管理（尽管python不需要管理） 链接表的缺点 定位访问需要线性时间 双链表在实现高效访问前后元素的时候，需要更多的存储空间。 存储一个表元素，就还需要存储一个链接域 表的应用 Josephus问题 代码依然见这里 第一种实现方法josephus_A由于需要遍历，算法复杂度很麻烦。这里暂时不细纠了。 第二种实现方法基于顺序表，见josephus_L，这种实现方式的复杂度为O（n^2） 第三种基于循环单链表，创建了一个Josephus类。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（一）-抽象数据结构]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhon%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[抽象数据类型的概念 一个数据类型的操作通常可以分为三类： 构造操作：基于已知信息，产生同样类型的新对象； 解析操作：基于已知信息，产生不同类型的新对象； 变动操作：修改被操作对象的内部状态。 静态方法和类方法 静态方法：通过在类前添加修饰符@staticmethod实现，本质上为普通函数。它没有self参数； 类方法：以访问属性的形式调用，调用它的类将自动约束到方法的cls参数。可通过该参数方位该类的其他属性。 在编程过程中，__init__方法通常都用来检查参数的合法性，设置参数的数据属性。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（五）-类和对象]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（五）——CHAP6 类和对象 重点： 类的构造方法 类 类的声明 类体 类体中包含变量的声明以及类方法的定义。 类的构造方法 构造方法的名称和类名相同 没有返回类型，返回值，也不需要修饰符 虽然看起来和一般的成员方法没有区别，但不能被直接调用，只能被new运算符调用 构造方法不能被继承（因为它不是类的成员） 子类可以调用父类的构造方法 【举个栗子】 创建一个car类并调用。 1234567891011121314151617181920212223242526class Car&#123; private String Brand; int gas; Car (String vBrand, int vgas )&#123; //构造方法 Brand = vBrand; gas = vgas; &#125; void run()&#123; if (gas &gt; 0) gas -=10; else System.out.println("没油了，不能跑啦~"); &#125; void Disp()&#123; System.out.println("品牌："+Brand+"油量"+gas); &#125;&#125;class Example6_1&#123; public static void main(String args[])&#123; Car MyCar = new Car("Audi", 10); //创建对象mycar MyCar.Disp(); //调用disp方法 MyCar.run(); //调用run方法 System.out.println("car is running……"); MyCar.run(); &#125;&#125; 成员变量]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（四）-数组]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（四）——CHAP5 数组 重点： java的高维数组每一个维数可以不一致 冒泡排序法 数组是用相同类型的元素组成的集合。这些元素可以是基本数据类型，也可以是构造出的数据类型。 包含以下几个部分： 数组名 数组类型 数组长度（有几个元素？） 数组中的元素是有顺序的。 一维数组 声明： int a[];或者int [] a;均可。 初始化： 直接在声明时初始化：int a[] = {1,2,3};，可用于元素较少的时候。 但是不能先声明再使用静态的初始化: 12int a[];a = &#123;1,2,3&#125;//会报错! 为数组分配内存空间，后续再赋值 12类型 数组名[];数组名 = new 类型[数组长度]； 例如： 12345int a = new int[4];a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; 【举个栗子】 实现冒泡升序排列 12345678910111213141516171819public class BubbleSort&#123; public static void main(String args[]) &#123; int i,j; int intArray[] = &#123;35,22,51,10,60&#125;; int len = intArray.length; for (i = 1; i &lt; len; i++) for (j = 0; j &lt; len - i - 1; j ++) if (intArray[j] &gt; intArray[j+1]) &#123; int t = intArray[j]; intArray[j] = intArray[j + 1]; intArray[j + 1] = t; &#125; System.out.println("the result after bubblesort: "); for (i = 0; i &lt; len - 1; i ++) System.out.println(intArray[i]); &#125; &#125; 把数组传递给方法 多维数组 二维数组的声明&amp;创建 声明： 12int a[][];double [][] b; 分配内存空间 直接为每一维分配空间： int a = new int[2][3];创建一个2*3维的数组； 从最高维开始分配：123int b = new int [2][];b[0] = new int[3];b[1] = new int[5]; 得到的形式如下： b[0][0] b[0][1] b[0][2] b[1][0] b[1][1] b[1][2] b[1][3] b[1][4] 注意 java数组的每一维不需要等长。 使用new分配内存时，至少需要给出最高维的大小。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（三）-程序流控制结构和方法]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E7%A8%8B%E5%BA%8F%E6%B5%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（三）——CHAP4 程序流控制结构和方法 重点： if elif条件嵌套 多选择结构switch+case 带标号的continue&amp;break 递归算法 switch语句 【举个栗子】switch + 三目条件运算（见笔记（一）） 本例可以把输入的字符串转换成数字： 以及在Java中，用双引号&quot;&quot;括起来的为String,用单引号’'括起来的是Char 12345678910111213141516171819202122232425262728293031import java.io.*;class SwitchTest2&#123; public static void main(String args[]) throws IOException &#123; char ch; System.out.print("enter a month: "); //这里是因为没有办法输入10,11,12这种两个字符的字节,故而用a,b,c代替 ch = (char)System.in.read(); &#123; System.in.skip(2); switch( (ch == '1'||ch == '2'||ch == 'c')?1: (ch == '3'||ch == '4'||ch == '5')?2: (ch == '6'||ch == '7'||ch == '8')?3: (ch == '9'||ch == 'a'||ch == 'b')?4:5) &#123; case 1: System.out.println("春季"); break; case 2: System.out.println("夏季"); break; case 3: System.out.println("秋季"); break; case 4: System.out.println("冬季"); break; default:System.out.println(ch + "是无效月份！"); &#125; System.out.print("switch语句出口！"); &#125; &#125;&#125; 结构化编程 for 循环 for(初值表达式1;循环条件表达式2;循环变量修改表达式3) 注定一定要确定循环条件，以防陷入死循环。 【举个栗子】计算1-100整数之和 123456789class LoopTest3&#123; public static void main(String args[])&#123; System.out.println("0-100 个整数之和 ：\n"); int i, sum = 0; for(i = 1; i &lt;= 100; i++) sum += i; System.out.println("sum=" + sum + ",i =" + i ); &#125;&#125; 另外，如果i是循环for里面定义的，则只在循环内有效。 【补充】用for循环实现和while一样的结构 123456int x = 10;for (;;;)&#123; if ( x &gt; 0) break; x -- ;&#125; 这时则需要和break结合。 嵌套循环和continue和break 带标识的continue 添加一个合法的JAVA标识符，并在其后面跟上冒号。 【举个栗子】 1234567891011121314151617181920import javax.swig.JOptionPane;public class ContinueLabTest&#123; public static void main(String args[]) &#123; String output = ""; rownext：//添加标识符 for (int row = 1; row &lt;= 5; row ++) &#123; output += "\n"; for(int column = 1; column &lt;= 10; column ++) &#123; if (column &gt; 2 * row - 1) continue rownext; //这里就是带标识的地方，跳出第二层for循环，回到外层的循环并判断循环条件。 output += "*"; &#125; &#125; JOptionPane.showMessageDialog(null, output, "testing continue with a label", JOptionPane.INFORMATION_MESSAGE); System.exit(0); &#125;&#125; break语句 break语句除了放在循环里，还能放在switch里。 break也可以带标号，常用在跳出多重循环里，只要在想跳出的循环前面加上break标号。 算法设计 这里先看一个基础的：递归 【举个栗子】用递归方法求阶乘LoopDGc 123456789101112131415class factor&#123; public long factorial(long n)&#123; if (n == 1) return 1 else return n * factor(n-1) &#125;&#125; public class LoopDGc &#123; public static void main (String args[]) &#123; long n = 20l; factor a = new factor(); long result = a.factorial(n); System.out.println(" "+n+" 的阶乘为" + result); &#125;&#125; 实际上这个地方还没怎么明白，尤其是主类和普通类。 首要还是要明白递归是什么东西……]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（二）-输入和输出]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（二）——CHAP3 Java的输入和输出 重点： System.out.write() 流式交互(InputStreamReader + BufferedReader) 标准输入/输出方法 Java里System包提供输入/输出流。 输出方法 println()输出后换行； print()输出后不换行； write()则被用来输出字节数组 以下举例： void println(char[] X)输出一个字符数组 void write(int b [])输出字节数组中的某一个元素，其后不换行。 123456789class PrintDemo&#123; public static void main(Strng args[])&#123; byte b[] = &#123;'f','g','h','i'&#125;; System.out.write(b,0,2); System.out.println(); //因为write后不换行，所以这里用println换行 System.out.write(b[0]); &#125;&#125; 输出结果是：fg和f 标准输入方法 用System.in.read()方法，有以下三种格式： 123public abstract in read() //从键盘输入一个字符public int read(byte[] b) //一次输入多个字节，并存在字节数组b中public int read (byte[] b, int off, int len)//限定输入的字节 另外，因为键盘输入很容易出错，所以必须引入异常处理机制。引入格式有两种 在main方法后直接用throws java.io.IOException子句抛出异常； 先在程序开头import java.io.*;加载语句,接着在main方法后加上throws IOExcrption子句来跑出异常。 【举个栗子】在键盘上一次输入多个字符并显示： 12345678910public class ReadCharDemo&#123; public static void main(String args[]) throws java.io.IOException &#123; byte b[] = new byte[16]; //定义长度为16的数组 System.out.println("\n 从键盘输出不超过16个字符，按回车键结束") System.in.read(b); System.out.printlb("\n 从键盘输入的是：") System.out.write(b,0,16);//用write直接输出字节数组。 &#125;&#125; 注意 如果用的是print方法，则需要把每一个元素都转化成字符，比较麻烦。 使用read方法时，还可以用read(b, 0, 10)来限制读入长度。（见上面提到的方法3） 利用命令行传入参数 123456public class HelloArgs&#123; public static void main(String args[]) &#123; System.out.println(args[0] + args[1] + "Hello!"); &#125;&#125; 接着可以在命令行里直接传递参数： 12E:\code\java-learning&gt; java HelloArgs 王可 王小可王可王小可Hello! 流式交互 1234567891011import java.io.*;public class HelloA1&#123; public static void main(String [] args) throws IOException &#123; InputStreamReader reader = new InputStreamReader(System.in); BufferedReader input = new BufferedReader(reader); System.out.print("Enter your name:"); String name = input.readLine(); System.out.println("Hello," + name + "!"); &#125; 这里reader作为InputStreamReader的一个实例存在，并且用作输入的System.in对象与之绑定； 接下在input作为BufferedReader的一个实例，与reader绑定； 用input的readLine方法来从键盘读取一整行的文字即可。 图形界面&amp;自定义类 以后再填坑，目前用不上，跳过。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown必要语法补充]]></title>
    <url>%2F2018%2F09%2F11%2FMarkDown%E5%BF%85%E8%A6%81%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[编号： 使用数字+.+半角空格 代码块高亮 插入数学公式。 可以使用MathJax引擎。如果要用hexo进行部署，且使用的是next主题，则可直接在站点配置文件中更改： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 把enable改为true。 另外，安装hexo-math插件,可以实现MathJax的自动部署： 1npm install hexo-math --save 感受一下： x1+x2=x3x_1 + x_2 = x^3 x​1​​+x​2​​=x​3​​ 编写语法和tex语法一致。]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（一）-语言基础]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（一）——CHAP2 JAVA语言基础 重点：最终变量、三元条件运算、位运算、MATH类 TIPS 注释格式 //表示单行注释 多行注释以/*开始，*/结尾 编程习惯 所有语句以分号结尾； Java区分大小写； 类名称以大写字母开头，变量以小写字母开头； 驼峰命名法； 文件名需要和public类在拼写和大小写上一致； JAVA语言基础 基本构成 标识符 所有标识符必须以A~Za~z，_或者$开头；（尤其注意不能以数字开头）； 流行的命名方式 常值标识符——全部大写： RED 类名标识符——大写字母开头+驼峰：MyCar 公有方法/实例变量——小写开头+驼峰：getCurrentValue 关键字 for while boolean …… 分隔符 注释 空白符（回车、TAB、换行），会被忽略 普通分隔符（{} ; , :） 直接量 运算符 数据类型 基本数据类型 整型：byte, short, int, long; 浮点型：float, double, 字符型：char 布尔型：boolean 直接量 程序中使用的常量 整数、浮点数、布尔值、字符、字符串 变量 一般变量要经历以下几个步骤 声明变量 变量的作用域和生命周期 最终变量 这个概念第一次听说。高亮~ 它指的是在运行过程中值不变的量，有点类似于常量。 定义的方法有两种。 直接定义： final double PI = 3.1415； 在声明的变量前加关键字，必要时再初始化： 123final double PI;……PI = 3.14159； 变量类型的转换 自动转换：两个类型兼容/目标类型大于原类型（比如byte转double) 强制转换 运算符&amp;表达式 只有一点要注意： 1234int i = 10;int j = 10;x = i ++;y = ++ j; x的值为10， y的值为11。所以++的位置要注意 逻辑运算符： !逻辑非 &amp;&amp;逻辑和 ||逻辑或 三元条件运算符 exp1&gt;exp2:exp3 例如： 12x = 10;y = x &gt; 9 ? 100:200 输出y为100，否则y为200 MATH类的操作 Math在JAVA.lang类包里。 调用e和PI:Math.E Math.PI 最大最小化：Math.max(val,val) Math.min(val,val) 绝对值: Math.abs() 四舍五入： Math.round() Math.rint() Math.ceil() Math.floor() 幂和对数:exp(),pow(),log() 三角函数：Math.sin()等]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java10的环境配置]]></title>
    <url>%2F2018%2F09%2F10%2Fjava10%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[好久没碰JAVA，今天重新下了个JDK10，发现配置较之前学习的有所变化。主要是PATH和JRE的环境配置： CLASSPATH配置 首先在环境变量中添加JAVA_HOME为jdk的安装路径； 新建一个CLASSPATH的系统变量，并添加.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 注意前面不要忘记加点和分号。 PATH配置 直接用绝对路径，添加&lt;PATH_TO_JDK\bin&gt; （并不需要把jre也加进去） 验证安装是否成功 老三样，打开cmd，依次输入： 123java -versionjavacjava 都成功就说明装完啦~]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[刚开学没事干，所以想着来搭个博客吧。也是为了激励自己能够养成及时总结的习惯。 hexo+github的博客搭建教程网络上很多，我主要搜了知乎的这一篇，讲得很详细：GitHub+Hexo 搭建个人网站详细教程 此外这个作者的汇总做的也不错：Hexo+GithubPages&amp;CodingPages搭建自己的个人博客 还有这个作者的汇总：我的个人博客之旅：从jekyll到hexo 设置多个tags以及categories 在写这个blog的时候还发现，如果直接在tags后面写多个tags会显示成一个，这是不行的。 这里提供了解决方法：hexo搭建博客–给文章添加多个tag或category 注意这里的categories是直接显示的侧边栏。 以下是一些常用个性化设置： 修改文本链接样式： 链接文本改为蓝色，鼠标划过时文字颜色加深： 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 1234567.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; &#125;&#125; 在侧边栏添加tags： 新建一个页面，命名为 tags： 1hexo new page tags 这会在blog的根目录的source下生成一个tags文件夹，文件夹里面带了一个index.md 点进去，修改： 12345---title: tagsdate: 2018-09-08 15:23:35type: &quot;tags&quot;--- 注意不要忘记在冒号之后打半角空格 增加搜索框 以下是网络上的方法，但是我尝试了一下没啥用= = 首先安装hexo-generator-searchdb插件(在blog的根目录下) 1npm install hexo-generator-searchdb --save 接着，找到站点配置的_config.yml文件，在任意位置添加： 12345search: path: search.xml field: post format: html limit: 10000 以下是next主题配置自带的功能： 在next的_config.yml文件夹下，找到“local_search”这一栏，把默认的false改为“auto&quot;(自动匹配)或者”manual&quot;(手动匹配)即可。 1234567local_search: enable: auto # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 控制预览字数/博文缩略显示 在想要断页的地方添加：&lt;!--more--&gt;，可以精确控制字数； 或者在next的_config.yml文件中，找到auto_excerpt项，然后把底下的false改为true。这样可以控制每篇blog都显示相同的字数。 markdown-it-plus 这个底下有不少插件 首先，卸载原有的渲染工具： 1234npm un hexo-renderer-marked --save#卸载旧的默认Markdown插件npm install hexo-renderer--markdown-it-plus --save#安装新的增强型插件 插入数学公式 使用katex，首先，需要安装katex支持插件： 1npm install markdown-it-katex 接下来，在站点配置文件中，把markdown-it-plus自带的mark关闭，并开启katex： 12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false 配置完之后，还需要在网页中引入相关的CSS文件，如果不想每次都写的话，可以在next主题里themes\next\layout\_custom\header.swig文件中修改，写入如下内容： 这里我踩了个坑，markdown-it-katex官方给的最新的katex文件渲染的上下标有问题，改为下面这个版本后解决了。 12&lt;link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"&gt;# 不要引入最新的katex文件，显示效果和插件并不兼容 接着，安装自动渲染的插件：hexo-math 1npm install hexo-math 然后在站点配置文件中添加如下内容 1234567891011math: engine: &apos;katex&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 就可以啦。实现如下： a2+b2=c1a^2 + b ^ 2 = c_1 a​2​​+b​2​​=c​1​​ 设置脚标 markdown本身是自带脚标的，可以在正文里输入&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在文章末尾加上： 即可。 但是hexo并不支持这种渲染。好在markdown-it-plus里也可以设置。在安装了markdown-it-plus插件后，再安装其附属： 1npm install markdown-it-footnote 配置文件只需要写如下内容就可以： 123456789markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ 因为footnote这个插件是默认打开的。如果需要关闭的话，在markdown-it-plus的配置下再添加 1234plugins: - plugin: name: markdown-it-footnote enable: false 就可以。 next 背景的动态化设置。 背景设置在5.1版本之后方便了很多，在next主题配置文件里找到： 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: true# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 这几个是用来配置背景的，可以喜好选择true/false来开启和关闭这些动图。 添加头像 这个很简单，在next主题配置文件中，找到： 12# Sidebar Avataravatar: /images/avatar.jpg 把avatar前面的#去掉即可。头像图片放在next/source/images里。 使用gitment添加评论 我觉得gitment比较方便的是不用另外注册账号了~ 主要参考这篇的配置 利用七牛云作为图床。 七牛云图床插件 账号配置与使用：点这里 测试：]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
