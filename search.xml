<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BBC《Civilisations》]]></title>
    <url>%2F2020%2F01%2F22%2FBBC%E3%80%8ACivilisations%E3%80%8B%2F</url>
    <content type="text"><![CDATA[我们曾花了很长时间来争辩文明是抑或不是什么，但当它的对立面出现时，在种种暴虐、残忍、偏执和毁灭欲中，我们立刻就会明白何为文明。 我们曾花了很长时间来争辩文明是抑或不是什么，但当它的对立面出现时，在种种暴虐、残忍、偏执和毁灭欲中，我们立刻就会明白何为文明。]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>纪录片</tag>
        <tag>BBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人类简史》笔记]]></title>
    <url>%2F2020%2F01%2F16%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[人类简史（新版）：从动物到上帝 尤瓦尔·赫拉利 ◆ 第一部分 认知革命 在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。 他们万万没有想到，他们的后代某一天竟能在月球上漫步、分裂原子、了解基因码，还能写写历史书。 ◆ 第二章 知善恶树 即使到了今天，绝大多数的人际沟通（不论是电子邮件、电话还是报纸专栏）讲的都还是八卦。这对我们来说真是再自然不过，就好像我们的语言天生就是为了这个目的而生的。你认为一群历史学教授碰面吃午餐的时候，聊的会是第一次世界大战的起因吗？而核物理学家在研讨会中场茶叙的时候，难道讲的会是夸克？确实有时候是如此，但更多时候其实讲的都是哪个教授逮到老公偷吃，哪些人想当上系主任或院长，或者说又有哪个同事拿研究经费买了一台雷克萨斯之类。八卦通常聊的都是坏事。这些嚼舌根的人，所掌握的正是最早的第四权力，就像是记者总在向社会爆料，从而保护大众免遭欺诈和占便宜。 然而，人类的社会本能也和黑猩猩没有什么不同，只适用于比较亲近的小团体。等到这个团体过大，社交秩序就会崩坏，使团体分裂 然而，以上这些东西，其实都只存在人类自己发明并互相讲述的故事里。除了存在于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。 标致公司只是我们的一个集体想象，这种想象在法律上称为“法律拟制”（legal fiction）。 。说穿了，就是讲故事，再说服听众相信这些故事。 然而，要说出有效的故事，其实并不容易。难点不在于讲故事，而在于要让人相信。 人类和黑猩猩之间真正不同的地方就在于那些虚构的故事，它像胶水一样把千千万万的个人、家庭和群体结合在一起。这种胶水，让我们成了万物的主宰。 ◆ 第三章 亚当和夏娃的一天 ，即使到了现在，我们的大脑和心灵都还是以狩猎和采集的生活方式在思维。我们的饮食习惯、冲突和性欲之所以是现在的样貌，正是因为我们还保留着狩猎采集者的头脑 而正因为虚构故事已经出现，即使是在类似的生态、同样的基因组成下出现的人类，也能够创造出非常不同的想象现实，表现出来就成了不同的规范和价值观。 从认知革命之后，智人的“自然生活方式”从来就不止一种。 换句话说，采集者对于他们周遭环境的了解，会比现代人更深、更广也更多样。现代的工业社会中，就算不太了解自然环境也能顺利存活。像是如果你是个计算机工程师、保险推销员、历史老师或是工厂工人，你真的需要了解自然环境吗？现代人必须专精于自身小领域的知识，但对于其他生活中的必需，绝大多数都是靠着其他各领域的专家，每个人懂的都只限于自己的那一小方天地。就整体而言，现今人类所知远超过远古人类。但在个人层面上，远古的采集者则是有史以来最具备多样知识和技能的人类。 我们已经看到，采集社会可能有许多不同的宗教和社会结构，可以预测他们也同样有不同的暴力倾向。可能在某些时期，某些地区一片平静祥和，但在其他地区却是动乱不断。 ◆ 第二部分 农业革命 农业革命所带来的非但不是轻松生活的新时代，反而让农民过着比采集者更辛苦、更不满足的生活。 人类以为自己驯化了植物，但其实是植物驯化了智人。 人类进到农业时代后出现了大量疾病，例如椎间盘突出、关节炎和疝气。 就像今天如果要说某家公司行不行，我们看的是它的市值有多少钱，而不是它的员工开不开心； 这很节能 这正是农业革命真正的本质：让更多的人却以更糟的状况活下去。 这正是农业革命真正的本质：让更多的人却以更糟的状况活下去。 断，断舍离？ 奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务。等到习惯某种奢侈品，就开始认为这是天经地义。接着就是一种依赖。最后，生活中就再也不能没有这种奢侈品了。 奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务。等到习惯某种奢侈品，就开始认为这是天经地义。接着就是一种依赖。最后，生活中就再也不能没有这种奢侈品了。 我们以为自己省下了时间；然而，我们其实是把生活的步调加速成过去的10倍快，于是我们整天忙忙碌碌、焦躁不安。 人类一心追求更轻松的生活，于是释放出一股巨大的力量，改变了世界的面貌，但结果并没有任何人料想得到，甚至也不是任何人所乐见的。并没有人在背后操纵农业革命发生，或是意图让人依赖谷类为生。一开始只是各种小事，主要就是希望吃饱一点、生活安全一点，但最后累积引起的效应，就是让远古的采集者开始花上整天的时间，在烈日之下挑水务农。 哥贝克力石阵显示，很有可能其实是先建立起信仰中心，之后才围绕着它形成村子。 虽然就演化而言，驯化的鸡和牛很可能是最成功的代表，但它们过的其实是生物有史以来最惨的生活。 驯化动物的过程几乎总是会将雄性阉割，好抑制雄性的侵略性，也让人类能够控制挑选牲畜的生育。 很可能就是物种演化上的成功并不代表个体的幸福。 ◆ 第六章 盖起金字塔 在农业革命之后，人类成了远比过去更以自我为中心的生物，与“自己家”紧密相连，但与周遭其他物种画出界线 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作、胼手胝足。他们生产出来的多余食粮养活了一小撮的精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是，历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。 这种灾难的根源在于，人类在几百万年的演化过程中，一直都只是几十人的小部落。从农业革命之后，不过短短几千年就出现了城市、王国和帝国，但时间并不足以让人类发展出能够大规模合作的本能。 大多数的人类合作网络最后都成了压迫和剥削。 这种担心其实很有道理。自然界的秩序是稳定不变的，就算人类不再相信世界上有重力，重力也不会一夜之间就消失。但相反的是，想象所建构出来的秩序总是有一夕崩溃的风险，因为这些秩序背后靠的都是虚构的故事，只要人们不再相信，一切就风云变色。 很多时候，一名牧师的效果大过一百个士兵，而且更便宜、更有效。 然而暴力活动一旦开始，想收手就很难了 在所有的人类集体活动中，最难组织推动的就是暴力活动。 如果人们希望某个由想象建构出的秩序能维持久远，大部分的人（特别是大部分的精英分子）就必须真正相信它。如果不是大多数中国人都相信仁义礼智信，儒家思想绝不可能持续了两千多年。如果不是大多数的美国总统和国会议员都相信人权，美国的民主也不可能持续了250年。如果不是广大的投资人和银行家都相信资本主义，现代经济体系连一天也不可能继续存在。 要怎样才能让人相信这些秩序？第一，对外的说法绝对要坚持它们千真万确、绝非虚构。 第二，在教育上也要彻底贯彻同一套原则。 旅游业真正卖的可不是机票和饭店房间，而是旅游中的经验。 一如古埃及精英分子，现在大多数人一生汲汲营营，也都是想盖起某种金字塔，只不过这些金字塔在不同文化里会有不同的名字、形体和规模罢了。举例来说，可能是一栋近郊的独栋透天别墅，有游泳池和大庭院，也可能是一个闪闪发光的高楼公寓，有着令人屏息的美景。但很少人会真的去问，究竟为什么我们会开始想建这些金字塔？ 由此可见，为了改变现有由想象建构出的秩序，就得先用想象建构出另一套秩序才行。 ◆ 第七章 记忆过载 因为智人的社会秩序是通过想象建构，维持秩序所需的关键信息无法单纯靠DNA复制就传给后代，需要通过各种努力，才能维持种种法律、习俗、程序、礼仪，否则社会秩序很快就会崩溃。 因此，演化压力让人类的大脑善于储存大量关于动植物、地形和社会的信息。 一些不知名的苏美尔天才发明了一套系统，可以在人脑之外储存和处理信息，专为处理大量数字数据所量身打造。 苏美尔人的数字系统分别以6和10作为基数。即使到现在，人类生活还是处处可见以6为基数，像是一个圆有360度，一天有24小时。 至今，大脑为何能做到这样仍然是一个谜，但我们都知道它的检索系统效率惊人。（只不过，找钥匙这件事可能是个例外。） 容易让人搞错的一点在于，虽然这些符号现在被称为“阿拉伯数字”，但其实是印度人发明的 只要能将信息转成数学符号，储存、传播和处理的速度和效率就能快到令人叹服。 因此，如果哪个人想打动政府、组织和企业，就必须学会“用数字说话”。而专家也费尽心力，甚至像是“贫穷”、“幸福”和“诚实”这些概念，都能翻译成一个又一个的数字，成了“贫穷线”、“主观幸福感程度”、“信用等级”。而像是物理和工程方面，几乎整个知识领域都快要和人类的口语语言脱节，而由数学符号独挑大梁。 ◆ 第八章 历史从无正义 简单的讲法，是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足。 然而就我们目前所知，这些阶级区别不过全都是人类想象的产品罢了。不管是婆罗门还是首陀罗，都不是诸神从某个原人的不同身体器官所创造出来的 阶级固化？ 但事实已经证明，大多数有钱人之所以有钱，只是因为他出生在有钱的家庭，而大多数穷人一辈子没钱，也就只是因为他出生在贫穷的家庭而已。 但事实已经证明，大多数有钱人之所以有钱，只是因为他出生在有钱的家庭，而大多数穷人一辈子没钱，也就只是因为他出生在贫穷的家庭而已。 当然，天生自然的能力也很可能影响社会阶级差异，但是种种不同的能力和性格常常还是会受到想象阶级的影响。 第一，也是最重要的一点，就是大多数的能力也需要培养和发展 … 。他从小被迫与能力出色的巫师父母分离，而由对巫术一无所知的麻瓜带大，所以等他到了霍格华兹的时候，对巫术可以说是一窍不通。于是，他的故事整整写了7本书，他才真正掌握了这项独特才能的力量和知识。 第二，就算身处不同阶级的人发展出了完全一样的能力，因为他们面对的游戏规则不同，最后结果也可能天差地别。 当时出现的白人至上主义的秘密社团“三K党”（Ku Klux Klan） 我们究竟要如何才能判断，什么是真正在生物学上有所不同，而什么又只是人类说得煞有介事、自找借口？一项黄金法则就是“天生带来允许，文化造成封闭”。 文化总会说，它只是禁止“不自然的事”。但从生物学的角度来看，这世界上根本没有什么是不自然的。 事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意” 演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化 所以，坚持女性生小孩才“自然”或者说同性恋“不自然”，其实并没什么意义。各种规定男人就该如何、女人就该怎样的法律、规范、权利和义务，反映的多半只是人类的想象，而不是生物天生的现实。 正由于定义男女角色、权利和责任的并不是生物学，而只是虚构的故事，所以每个社会认为“够男人”和“够女人”的意义也就大不相同 有些共通的生物因素，让几乎所有文化都重视阳刚胜过阴柔。我们并不知道真实的原因为何，虽然有各种理论，但没有任何一个真能完全站得住脚。 更重要的是，就人类整体来说，体力和社会权力本来就没有直接关 ◆ 第三部分 人类的融合统一 文化一直想弭平这些矛盾，因此就会促成改变 然而，合久必分只是一时，分久必合才是不变的大趋势。 然而，全球文化虽然单一，却非同质。就像是单一的有机体有许多不同的器官和细胞，单一的全球文化也包含着许多不同类型的人和生活方式，既有纽约的股票经纪人，也有阿富汗的牧羊人 ◆ 第十章 金钱的味道 事实上，就算是现在，大部分的钱也不是以硬币或钞票的方式存在。全球金钱总和为60兆美元，但所有硬币和钞票的金额加起来还不到6兆美元。￼换句话说，所有的钱有超过九成（超过50兆美元！）都只是显示在计算机上的数字而已 人人都想要”正是金钱最基本的特性。 人们之所以愿意如此，正是因为他们接受了这个集体的想象。“信任”正是所有金钱形式最基本的原料。如果有个富裕的农民卖掉房舍田产换来一袋贝壳，还带着这袋贝壳前往远地的省份，那是因为他相信抵达之后，其他人会愿意用稻米、房屋和田地和他交换这些贝壳。所以，可以说金钱就是一种相互信任的系统，而且还不是随随便便的某种系统：金钱正是有史以来最普遍也最有效的互信系统。 正因如此，铸造伪币的罪行一直比其他诈欺行为判得更重。因为造伪币不只是单纯的诈欺，更是对主权的挑战，直接冒犯了国王的权力、特权和他本人 原因就在于宗教信仰的重点是自己相信，但金钱信仰的重点是“别人相信”。 金钱制度有两大原则： 1.万物可换：钱就像是炼金术，可以让你把土地转为手下的忠诚，把正义转为健康，把暴力转为知识。 2.万众相信：有了金钱作为媒介，任何两个人都能合作各种计划。 所以，说到人类终将统一，绝不只是纯粹经济的过程。想知道原本成千上万的独立文化是如何逐渐相连、形成今天的地球村，虽然黄金和白银影响深远，但也别低估了刀剑的力量。 ◆ 第十一章 帝国的愿景 努曼西亚仍然是西班牙英雄主义和爱国主义的典范、年轻人心中的丰碑。 这种情节不太符合我们的品位，我们爱看的是反败为胜，是小人物的胜利。然而，历史就是没有正义。多数过去的文化，早晚都是遭到某些无情帝国军队的蹂躏，最后在历史上彻底遭到遗忘。就算是帝国本身最后也将崩溃，只是常常留下丰富而流传千古的遗产。在21世纪，几乎所有人的祖先都曾经属于某个帝国。 帝国是一种政治秩序，有两项重要特征。第一，帝国必须统治着许多不同的民族，各自拥有不同的文化认同和独立的领土。但多少民族才算数？两三个民族还不够，而二三十就算很多；要迈进帝国的门槛，其统治的民族数量，大概就介于两者之间。 第二，帝国的特征是疆域可以灵活调整，而且可以几乎无限扩张。帝国不需要改变基本架构和认同，就能够纳入更多其他国家和领土。说到今天的英国，如果不改变基本架构和认同，就很难再突破现有的疆界。但在1个世纪前，全世界几乎任何地方都有可能成为大英帝国的一部分 帝国正是造成民族多样性大幅减少的主因之一。帝国就像一台压路机，将许多民族独特的多样性逐渐夯平（例如努曼西亚人），整合制造出他们更大的新群体。 此外，帝国政体其实非常稳定，多半时候要打倒反叛军根本不成问题。帝国之所以会倾覆，通常都是因为有外部侵略或是内部统治精英的内斗 每次一个帝国朝代崩溃，这种政治理论主流就让各方竞逐的势力不安于各自为政，而一心追求统一。而且事实证明，最后总能统一，只是时间早晚的问题。 结合前文提到的，大部分种族侵略需要一个合理的借口。人们只是无法忍受“异己”，带有偏见，才想要征服罢了。 至于这些好处，有时候确实显而易见（例如都市规划、统一度量衡），但有时候也十分可疑（像是税收、征兵、崇拜皇帝）。只不过，多数帝国精英仍然一心相信，自己是为了所有帝国子民的整体福利而努力。在中国的统治阶级眼中，各个邻国及四方诸侯都是生活水深火热的蛮夷之邦，天朝中国应该泽被四方、广传华夏文化。所谓的天命为的不是剥削掠夺整个世界，而是要教化万民。同样，古罗马人也声称自己的统治理所当然，因为他们让野蛮人开始有了和平、正义，生命也更为高雅。像是他们说日耳曼民族生性野蛮，高卢人会画各种战妆，生活肮脏，为人无知，一直要到古罗马人到来，才用法律驯化了他们，用公共浴室让他们身体洁净，也用哲学让他们思想进步。公元前3世纪的孔雀王朝，也认为自己必须负起责任，将佛法传播到无知的世界。穆斯林哈里发也肩负着神圣的使命，要传播先知的启示，虽然最好是以和平的方式，但必要的时候也不惜一战。至于西班牙和葡萄牙帝国，他们也声称自己到印度和美洲不是为了财富，而是要让人改信真正的信仰。号称日不落国的大英帝国，也是号称传播着自由主义和自由贸易这两大福音。苏联人更是觉得责无旁贷，必须协助推动这个历史的必然，从资本主义走向无产阶级专政的乌托邦。至于现代许多的美国人，他们也认为美国必须负起道义责任，让第三世界国家同样享有民主和人权，就算这得靠巡航导弹和F-16战机，也是在所不惜。 当代移民？ 对于被征服者而言，就算有了文化大熔炉之后，文化同化也不见得容易。虽然帝国文明很可能四方征服各个民族、融合他们的文化，但对帝国绝大多数成员来说，混合的成果仍然令他们感到陌生。同化的过程常常带着痛苦和创伤。要放弃熟悉且深爱的地方传统并不容易，而要了解及采用新的文化也同样困难而令人深感压力。雪上加霜的是，等到帝国的属民千辛万苦终于接受了帝国文化，可能也是在数十年甚至数百年以后，帝国的精英才能把他们看成是“我们”。从征服到接受之间的数个世代，就这样形成了失落的一群。他们已经失去了自己心爱的当地文化，但在新加入的帝国世界里却还没有一个平等的地位，反而只是继续被视为野蛮人。 没有人真正知道该如何解决文化遗绪这个棘手的问题。无论采取哪一种方式，第一步就是认清这种两难的复杂程度，知道历史就是无法简单分成好人和坏人两种。当然，除非我们愿意承认，自己常常就是跟着走坏人的路。 ◆ 第十二章 宗教的法则 因为所有的社会秩序和阶级都只是想象的产物，所以它们也十分脆弱，而且社会规模越大，反而就越脆弱。而在历史上，宗教的重要性就在于让这些脆弱的架构有了超人类的合法性 我们可以说宗教是“一种人类规范及价值观的系统，建立在超人类的秩序之上” 一种人类规范及价值观的系统，建立在超人类的秩序之上” 宗教认为世界有一种超人类的秩序，而且并非出于人类的想象或是协议 这种超人类的秩序为基础，宗教会发展出它认为具有约束力的规范和价值观。 换句话说，宗教必须同时具备“普世特质”和“推广特质”。 过去以泛神论为主要信仰体系的时候，人类的规范和价值观不能只想到自己，还必须考虑其他动物、植物、精灵和鬼魂的想法和利益。 因此，农业革命最初的宗教意义，就是让动植物从与人类平等的生物，变成了人类的所有物。 多神论认为主宰世界的最高权力不带有任何私心或偏见，因此对于人类各种世俗的欲望、担心和忧虑毫不在意。 终于搞懂新教徒和天主教徒的区别了…所以新教徒相比天主教徒应该更为开放和自由一点，因为他们觉得该受的苦难已经由耶稣承担了。 新教徒认为，神如此爱着世人，所以让自己化为肉体，容许自己受到折磨、钉死在十字架上，从而赎了原罪，并对那些信他的人打开了天堂的大门。而天主教徒认为，虽然信仰是必要的，但光这样还不够。要进入天国，信徒还必须参加教堂礼拜，而且要多行善事。这点让新教徒无法接受，认为这样形同交易，对于神的爱和伟大是种贬抑。如果进不进天堂必须取决于自己的善行，岂不是放大了自己的重要性，而且暗示基督在十字架上为人类受的苦以及神对人类的爱都还不够？ 这种阶段可以称为“本地一神教” 一神教这么努力的源头是什么？到底是为了征服所以传教，还是为了传教所以征服呢 一般而言，一神教徒比多神教徒更为狂热、更热衷传教。毕竟，如果某个宗教愿意承认其他信仰，情况只有两种：第一种本来就认为世上没有唯一的神，而是有许多神同时存在；第二种认为虽然有一位最高的神，但下面分成许多小神祇，信仰每位神祇，可以说是看到了部分的真相。但由于一神教通常认为自己信奉的就是唯一的神，也认为只有自己看到了完整的真相，自然就会批评其他所有宗教都不可信。在过去两千年间，一神论者多次发动以暴力消灭其他竞争对手的战争，目的就是要加强自己的掌控 一般而言，一神教徒比多神教徒更为狂热、更热衷传教。毕竟，如果某个宗教愿意承认其他信仰，情况只有两种：第一种本来就认为世上没有唯一的神，而是有许多神同时存在；第二种认为虽然有一位最高的神，但下面分成许多小神祇，信仰每位神祇，可以说是看到了部分的真相。但由于一神教通常认为自己信奉的就是唯一的神，也认为只有自己看到了完整的真相，自然就会批评其他所有宗教都不可信。在过去两千年间，一神论者多次发动以暴力消灭其他竞争对手的战争，目的就是要加强自己的掌控 多神论除了促成一神教，也促成了一些二元论的宗教。二元论宗教信奉着善与恶这两种对立力量的存在。二元论与一神论不同之处在于，他们相信“恶”也是独立存在，既不是由代表“善”的神所创造，也不归神所掌管。二元论认为，整个宇宙就是这两股力量的战场，世间种种就是两方斗争的体现。 但无法否认的是，一神论面对“恶的难题”可以说是吃尽苦头。 哈哈哈哈因为明目张胆信奉恶神是不行的，不过，有一些极端的邪教会宣扬类似的想法？让人奉献自己啥的？突然想到了之前看的狂骨之梦的一些描写 其实，有一种解释能够同时处理这两大难题，而且完全合乎逻辑：世上确实有某个全能的神创造了全宇宙，而且他就是个恶神。只是古往今来，总没有哪个宗教说自己信了这一套。 太精辟了！ 结果就是，基督徒大致上是信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。像这样同时有着不同甚至矛盾的思想，而又结合各种不同来源的仪式和做法，宗教学上有一个特别的名称：综摄（syncretism）。很有可能，综摄才是全球最大的单一宗教。 结果就是，基督徒大致上是信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。像这样同时有着不同甚至矛盾的思想，而又结合各种不同来源的仪式和做法，宗教学上有一个特别的名称：综摄（syncretism）。很有可能，综摄才是全球最大的单一宗教。 这些新型宗教信仰包括印度的耆那教（Jainism）和佛教，中国的道教和儒教，以及地中海的犬儒主义（Cynicism）和享乐主义（Epicureanism），共同的特征就是崇拜的并非神祇。 他入禅6年，思索各种人类苦痛的本质、原因和解决方式。最后他体会到，一切苦难并非来自噩运、社会不公或是神祇的任性，而是出于每个人自己心中的思想模式。 但要怎样才能让心里接受事物的本质，而放下种种欲求，知道苦即为苦、乐即为乐？释迦牟尼制定一套冥想的技巧，能够训练心灵感受事物的本质而排除种种欲求。通过训练，心灵专注在“我现在是什么感受”，而不是问：“为什么是我？”这种境界很难达到，但并非不可能。 痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。 有神论的宗教，重点在神的崇拜；至于人文主义宗教，重点就是对人的崇拜，或者讲得更明确，是对智人的崇拜。人文主义的基本信念，就是认为智人是独特的、神圣的，从本质上就与其他所有现代动物有所不同。 人文主义对“人性”的定义，大致上分成三种对立的教派。今天最重要的人文主义学派就是自由人文主义，它认为人性就在于每个个人的自我特质，因此个人自由也就变得神圣不可侵犯 更多自由；而社会人文主义追求的，则是让所有人都能平等。 ◆ 第十三章 成功的秘密 事后解释 历史的铁则就是：事后看来无可避免的事，在当时看来总是毫不明显。 分成两级，一级混沌指的是“不会因为预测而改变”。例如天气就属于一级混沌系统。虽然天气也是受到无数因素影响，但我们可以建立计算模型，不断加入越来越多因素，让天气预报也越来越准确。 至于二级混沌系统，指的是“会受到预测的影响而改变”，因此就永远无法准确预测。 如果真能预测有革命，革命就永远不会成真 社会科学领域中，博弈理论也常有类似的论点。博弈理论告诉我们，在有多位参与者的时候，某些概念和行为模式可能对“所有”参与者都有害，但就是有办法继续存活下去 于是，无论我们把历史发展的动力称为博弈理论、后现代主义或迷因学，“提升人类福祉”绝不是其主要目标。并没有证据显示史上最成功的文化就一定是对智人最好的文化 ◆ 第四部分 科学革命 技术奇点的前兆 过去500年间，人类的力量有了前所未有的惊人成长。公元1500年时，全球智人的人口大约有5亿，但今天已经到了70亿。人类在1500年生产的商品和服务总共约合现值2500亿美元，但今天每年人类生产的价值约为60万亿美元。在1500年，全人类每天总共约消耗13万亿卡路里，但今天每天要消耗1500万亿卡路里。（看看这些数字，人口增加了14倍，生产增加240倍，消耗的能量增加了115倍。） 然而，如果要在过去500年间挑出一个最重大、具代表性的一刻，一定就是1945年7月16日上午5点29分45秒。就在这一秒，美国科学家在新墨西哥的阿拉莫戈多引爆了第一颗原子弹。从这时开始，人类不仅有了改变历史进程的能力，更有了结束历史进程的能力 科学革命并不是“知识的革命”，而是“无知的革命”。真正让科学革命起步的伟大发现，就是发现“人类对于最重要的问题其实毫无所知 毕竟，科学还是得倚靠着种种宗教和意识形态信仰，才能取得经费，并将研究正当化。 所以三体物理已死之时，那些物理学家才会自杀？ 现代社会之所以还能够维系，原因之一就在于对科技和科学研究方法的信任，这几乎成了类似宗教的信仰，甚至在一定程度上也取代了对绝对真理的信念。 这时候的重点不在于研究旧的知识体系，而是要强调新的观测、新的实验。如果现在观察到的现象与过去的传统知识体系相冲突，我们会认为现在的观察才正确。 一切学科学到最后都是数学，而数学学到最后将成为哲学 早期的知识体系常常是用“故事”构成理论，而现代科学用的则是“数学”。 居然在这里看到了自己的学科。。统计学果然是一级学科呢（ 这些计算要归功于当时不久前在统计与概率等领域的几项突破。其中之一是雅各布布·伯努利（Jacob Bernoulli）的大数法则（Law of Large Numbers）。伯努利认为，虽然某些单一事件（例如某个人死亡）难以准确预测，但只要有了许多类似事件，用平均结果来预测就能相去不远。换句话说，虽然麦克劳林无法用数学预测韦伯斯特和华莱士是不是明年就会过世，但只要有足够的数据，他就能告诉韦伯斯特和华莱士明年很有可能有多少位苏格兰长老教会牧师过世。 对“知识”的考验，不在于究竟是否真实，而在于是否能让人类得到力量或权力 1）社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；（2）生物性的贫穷，指的是因为缺乏食物和住所，而使人的生存受到威胁。或许社会性的贫穷永远都会存在、无法根除，但在全球许多国家中，生物性的贫穷都已经成了过去式。 事实上，许多社会现在的问题是营养过剩，胖死比饿死的概率更高。 然而，现在我们已经可以坦然承认。科学革命的一大计划目标，就是要给予人类永恒的生命 几位学者确实认为，到了2050年，就已经能够让某些人达到长生（a-mortal）的状态，只要不是因为意外而受到致命性伤害，就能将生命无限延长［而所谓的不死（immortal），则是指完全没有死亡的可能］ 现如今也是如此 科学研究之所以能得到经费，多半是因为有人认为这些研究有助于达到某些政治、经济或宗教的目的。例如在16世纪，国王和银行业者对于前往 因为资源有限，我们就必须回答像是“什么更重要”和“怎样才算花得适当”这种问题 总之，科学研究一定得和某些宗教或意识形态联手，才有蓬勃发展的可能。意识形态能够让研究所耗的成本合理化。而代价就是意识形态能够影响科学的进程表，并且决定如何使用研究成果。 ◆ 第十五章 科学与帝国的联姻 科学革命与现代帝国主义的关系密不可分。对于像是库克船长和植物学家班克斯来说，科学和帝国根本就是一家。就连倒霉的楚格尼尼也分不出这两者的概念有何不同。 中国和波斯其实并不缺乏制作蒸汽机的科技（当时要照抄或是购买都完全不成问题），他们缺少的是西方的价值观、故事、司法系统和社会政治结构，这些在西方花了数个世纪才形成及成熟，就算想要照抄，也无法在一夕之间内化 究竟欧洲在现代早期培养了什么潜力，让它能在现代晚期称霸全球？这个问题有两个答案、相辅相成：现代科学和资本主义。 欧洲帝国主义之所以要前往遥远的彼岸，除了为了新领土，也是为了新知识。 七大洲之中的两洲，名字就是来自一个名不见经传的意大利人，而他唯一做的事就只是有勇气说出“我们不知道”。 ◆ 第十六章 资本主义教条 这听起来就像是个巨大的庞氏骗局，不是吗？但如果你觉得这就是骗局一场，那么可以说整个现代经济就只是一场骗局。这事实上并不是件诈骗案，而是另一次人类想象力的惊人发挥。真正让银行（以及整个经济）得以存活甚至大发利市的，其实是我们对未来的信任。“信任”就是世上绝大多数金钱的唯一后盾。 现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。这样一来，才能带来更多的利润再重新投入生产，再带来更多的利润，如此不断循环。 想到了基督山伯爵 这样一来，风险减少，但可能的利润无上限。只要挑对了船，就算只有一点投资，你也可能变成百万富翁。 东印度公司原来是荷兰的！ 著名的荷兰股份制公司就是荷兰东印度公司（Vereenigde Oostindische Compagnie，简称VOC） 诺瓦里诺战役之后，英国资本家投资高风险海外交易的意愿就更高了。他们亲眼证实，如果外国债务人拒绝偿还贷款，女王陛下的军队就会去为他们讨债 这种观点就会认为，最明智的经济政策就是让政治不要干预经济，将税收和政府管制都减到最低，将一切交给市场力量，让其自由发挥。 人类的历史是血腥的历史。如果没有政府来维护人权，那么将会产生极端的二八原则。（大刘的一篇短篇写过当财富集中在某一人手上后会发生什么… 我们必须记住，人类的历史从来不是洁白无邪，大西洋奴隶贸易这件事绝非特例。 我们必须记住，人类的历史从来不是洁白无邪，大西洋奴隶贸易这件事绝非特例。 然而，这块经济大饼真的能无限制变大吗？每块饼都需要原材料和能源。但早有先知预言警告，迟早智人会耗尽地球上所有的原料和能源。这会在什么时候发生？ ◆ 第十七章 工业的巨轮 只要转换就一定有损耗；随着人类会转换的能量越来越多，损耗就一定也会越来越多 从此之后，人类就深深着迷于如何使用机器和引擎转换各种能量。 显然，这世界缺的不是能源，而是能够驾驭并转换符合我们所需的知识。如 工业化农业的悲剧在于，它一味强调动物的客观需求，却忽略了它们的主观需要。 这和我前面想过的太像了…原来农业已经发展得这么好了？ 例如现在的美国，只有2%的人口以农业为生，但仅仅就是这2%，不仅养活了整个美国的人口，还有剩余粮食可以出口到世界各地。 然而，消费主义的美德就是消费更多的产品和服务，鼓励所有人应该善待自己、宠爱自己，就算因为过度消费而慢慢走上绝路，也是在所不惜 富豪管理资产和投资非常谨慎，反而是没那么有钱的人，买起没那么需要的汽车和电视机却毫不手软。 反而是穷人在消费上投入更多的钱 资本主义和消费主义的伦理可以说是一枚硬币的正反两面，将这两种秩序合而为一。有钱人的最高指导原则是——“投资！”而我们这些其他人的最高指导原则则是——“购买！” 资本主义和消费主义的伦理可以说是一枚硬币的正反两面，将这两种秩序合而为一。有钱人的最高指导原则是——“投资！”而我们这些其他人的最高指导原则则是——“购买！” 大多数人都能轻松达到资本/消费主义的理想。想要进入这种新伦理所承诺的天堂，条件就是有钱人应该继续贪婪下去，把时间投入赚更多的钱，至于一般大众则是要尽情满足自己的欲望和热情，想要什么就买什么。 ◆ 第十八章 一场永远的革命 直到现在，新闻广播开头的第一条仍然是现在时间，就算战争爆发也得放在后面再报。第二次大战期间，英国广播公司的新闻播送到纳粹占领下的欧洲地区，而每段新闻广播的开头就是大本钟报时钟声的现场直播，可以说正是自由的钟声。 现在想知道时间，可以看一下腕上的手表，瞄一眼你的手机，瞧一下床边的闹钟，盯一下厨房的挂钟，瞟一眼微波炉上的时间，瞥一下你的电视机或DVD机，甚至计算机上的任务栏都会告诉你现在几点。想要不知道现在几点，还真是得刻意花上一点功夫才行。 而子女就是最好的退休基金。 一般而言，常用产品和服务会出现在市场上的不到一成，多数还是由家庭和社群提供。 只要先存点钱，我们就能到养老院安度最后这段黄金岁月。 年轻人越来越不需要听从长辈的意见，而一旦孩子的人生出了任何问题，似乎看来总是可以怪在父母头上。 正如同核心家庭，只要社群的情感功能还没有完全被取代，就不会从现代世界消失。过去社群的物质功能，现在已经大部分由市场和国家接手，但在部落情谊、同舟共济这些情感上还有待努力。 现代所兴起的两大想象社群，就是“民族”和“消费大众”。所谓民族，是国家的想象社群。而所谓消费大众，则是市场的想象社群。 民族竭尽全力，希望能掩盖自己属于想象的这件事。大多数民族都会声称自己的形成是自然而然、天长地久，说自己是在最初的原生时代，由这片祖国土地和人民的鲜血紧密结合而成。 举例来说，就算我用的原料是放了两年的面粉、放了两年的油、放了两年的糖，做出来的也不会是放了两年的蛋糕。 举例来说，互联网是在20世纪90年代才开始广泛使用，至今也才是20年左右的事。但我们已经完全无法想象没有网络的生活会如何。 因此，想要定义现代社会的特色为何，就像要问变色龙究竟是什么颜色一样。我们唯一可以确定的特色，就是它会不断改变。 大家提到甘地的非暴力抵抗常常赞誉有加，但大英帝国其实也该得到部分的赞赏 这次不同。原因就在于，真正的和平不该只是“现在没有战争”，而是“不可能发生战争”。 国际政治过去的铁律就说，“任何两个相邻的政体，都会有某种可能，让他们在一年之内向对方宣战”。 战争已经不再那么有利可图，但和平却成了一笔越来越划算的生意 究竟孰是孰非？其实需要时间来证明。我们只要回顾过往就会发现，自己对于过去历史的看法总是受到近几年事件的左右。如果这一章是写在1945年或是1962年，可能看法就会偏向悲观。但正因为已经来到2014年，整个看待现代历史的观点也就相对比较愉快。 ◆ 第十九章 从此过着幸福快乐的日子 现在，阿姆斯特朗的脚印还留在无风的月球上，而3万年前也有个不知名的人，把手印留在雪维洞穴里；他们究竟谁比较快乐？ 但我觉得体验过现代社会的普通人回到过去真的不一定会更快乐；毕竟有更高的死亡率、更多的疾病、个人意志也更加压抑，不能获得精神上的解放。从马斯洛需求层次来说，现代人显然更容易达到金字塔的顶端； 不过，如果要把现代的穷人和古代帝王相比，那就真的不好说了。我的观点是，相同阶级的人类，幸福感显然是提高了的 历史学家很少问这样的问题。他们不去讨论秦朝人是不是比先前采集为生的人更快乐，伊斯兰兴起后，埃及人是不是对生活更满意，也不讨论欧洲帝国在非洲崩溃之后，数百万非洲人的幸福受到什么影响。然而，这些可以说是最重要的历史问题。目前大多数的意识形态和政治纲领，虽然都说要追求人类幸福，但对于幸福快乐的真正来源为何却还是不明就里。民族主义者会说政治自决能够带来快乐。共产主义者会说无产阶级专政能够带来快乐。资本主义者会说自由市场能够创造经济成长，能够教导人类自立自强、积极进取，所以能够为最多人带来最大的快乐。 虽然很少有人提出对于快乐的长期纵观研究，但几乎所有学者和大众心中都多少有些模糊的定见。常有人认为，历史不断进展，人类的能力也不断增加。而一般来说，我们会运用能力来减轻痛苦、满足愿望，所以我们想必过得比中世纪的祖宗们来得快乐，而他们又一定比石器时代的狩猎采集者来得开心。 因此，虽然说过去几十年似乎是人类前所未有的黄金年代，但想知道这究竟代表历史潮流已经有了根本转变，又或只是昙花一现的美好，目前还言之过早。 也已经是史上最大规模、最残暴的罪行。要评估全球幸福程度的时候，只看上层阶级、只看欧洲人、只看男性，都是巨大的错误。而且，或许只看人类也同样有失公允。 人类的超高适应性！总是会高估我们对某件事情得反应 但是如果心理学家再去做后续追踪研究，他们两个人的幸福感与事件发生当天早上的结果并不会有多大不同 快乐并不在于任何像是财富、健康甚至社群之类的客观条件，而在于客观条件和主观期望之间是否相符。 如果说快乐要由期望来决定，那么我们社会的两大支柱（大众媒体和广告业）很有可能正在不知不觉地让全球越来越不开心。 这么一来，就算是长生不老也可能会导致不满。假设科学找出了能够医治所有疾疾的万灵丹，加上有效抗老疗程和再生治疗，能够让人永葆青春，那么，最可能发生的事，就是整个世界感到空前的愤怒和焦虑。 那些无力负担这些医学奇迹的人（也就是绝大多数人），一定会愤怒到无以复加。 人类演化的结果，就是不会太快乐，也不会太痛苦。我们会短暂感受到快感，但不会永远持续。迟早快感会消退，让我们再次感受到痛苦。 有学者认为，人类的生化机制就像是个恒温空调系统，不管是严寒还是酷暑都要想办法保持恒定。虽然遇到某些事件会让温度暂时有波动，但最后总是会控制调整回到原来设定的温度。 确实，已婚的人比单身和离婚的人更快乐，但这不一定代表是婚姻带来了快乐，也有可能是快乐带来了婚姻。或者更准确来说，是血清素、多巴胺和催产素带来并维系了婚姻。那些生化机制天生开朗的人，一般来说都会是快乐和满足的。而这样的人会是比较理想的另一半，所以他们结婚的概率也比较高。而且，和快乐满足的另一半相处，绝对比和郁闷不满的另一半相处来得容易，所以他们也比较不容易离婚。 如果我们接受了生物学对于快乐的理论，历史这个学科的重要性就大减；毕竟，大多数的历史事件并不会对我们的生化机制有什么影响 历史上，只有一项发展真正有重大意义。现在我们终于意识到，快乐的关键就在于生化系统，因此我们就不用再浪费时间处理政治和社会改革、叛乱和意识形态，而是开始全力研究唯一能真正让我们快乐的方法：操纵人类的生化机制 ？？那其实只要自己过得顺遂根本没必要和他人比较 讲到这套生物学理论，最能抓到精髓的就是著名的新世纪（New Age）口号：“快乐来自内心。”金钱、社会地位、整形手术、豪宅、握有大权的职位，这些都不会给你带来快乐。想要有长期的快乐，只能靠血清素、多巴胺和催产素。 已经快忘记这本书了_(:з」∠)_把人类分级的那一本？ 《美丽新世界》 只要有想尝试的新idea，在图书馆呆着就不是一件痛苦的事情 正如尼采所言，只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。 人类只是在没有特定目标的演化过程中，盲目产生的结果 不论是创业者想要开新公司，或是中世纪的人想要读经、参与圣战、兴建新庙，他们从中感受到的意义，都只是错觉与幻想。 然而，这不过是自由主义独有的一个观点而已。历史上大多数的宗教和意识形态认为，关于善、关于美、关于何事应为，都有客观的标准。 根据道金斯《自私的基因》理论，正如同其他动物，人类在自然选择的影响下，就算对个人不利，他们也会选择要让基因继续流传下去。 佛教认为，快乐既不是主观感受到愉悦，也不是主观觉得生命有意义，反而是在于放下追求主观感受这件事。 佛教与现代生物学和新世纪运动的相同点，在于都认定快乐不在于外在条件。但佛教更重要也更深刻的见解在于，真正的快乐也不在于我们的主观感受。 ◆ 第二十章 智人末日 生物工程（biological engineering）、仿生工程（cyborg engineering）与无机生命（inorganic life）工程。 所谓生物工程，指的是人类刻意在生物层次进行的干预行为（例如植入基因），目的在于改变生物体的外形、能力、需求或欲望，以实现某些预设的文化概念（例如爱德华多·卡茨心中的那种艺术）。 工具人。。 另外也早有人预期将会出现生物独裁统治的末日场景，用复制的方式制造出不懂得恐惧为何物的士兵，不知道反抗是什么概念的工人。 完美的人类！=创造者自身完美，这才是最可怕的吧 如果基因工程可以创造出天才老鼠，为什么不创造天才的人呢？如果基因工程可以让两只田鼠长相厮守，何不让人类也是天生彼此忠贞不贰？ 操纵基因并不一定会让智人大批死亡而绝种，但很可能会让智人这个物种大幅改变，到最后就成了另一个物种，而不宜再使用智人这个名称。 这个病也太孤独了…… 闭锁症候群（locked-in syndrome）是一种神经疾病，病患会丧失几乎所有控制身体移动的能力，但认知能力却完全不受影响。罹患这种疾病的病人，最后只能用眼球微小的运动与外界沟通。然而，现在已经有几位病人的脑中植入了收集大脑信号的电极。目前科学家正在努力解译这些信号，希望不只能将信号转为动作，更能转为语言。 这样的生化人就不再属于人类，甚至也不再属于有机生物，而是完全不同的全新物种。这一切是根本上的改变，其中的哲学、心理或政治影响可能都还不在我们的掌握之中。 真正的大巫是吉尔伽美什计划以及未来创造出超人类的可能，将会为人类的伦理、社会和政治秩序带来巨幅改变 《赡养人类》 纵观历史，上层阶级总是说自己比下层阶级更聪明、更强壮，整体而言更为优秀。他们过去通常只是在自欺欺人，贫苦农家的孩子智力很可能和王子也相去不远。然而，在新一代医药推波助澜下，上层阶级的自命不凡可能即将成为一种客观事实。 ◆ 后记 变成神的这种动物 此外，虽然现在人类已经拥有许多令人赞叹的能力，但我们仍然对目标感到茫然，而且似乎也仍然总是感到不满。我们的交通工具已经从独木舟变成帆船、变成汽船、变成飞机，再变成航天飞机，但我们还是不知道自己该前往的目的地。我们拥有的力量比以往任何时候都更强大，但几乎不知道该怎么使用这些力量。更糟糕的是，人类似乎也比以往任何时候更不负责。我们让自己变成了神，而唯一剩下的只有物理法则，我们也不用对任何人负责。正因如此，我们对周遭的动物和生态系统掀起一场灾难，只为了寻求自己的舒适和娱乐，但从来无法得到真正的满足。 ◆ 点评 点评:★★★★★ 因为“简”，所以方方面面都不够具体，大部分内容可以在初高中的历史书上找到痕迹；另外，它也并不是纯粹的“史”，能很明显得感觉到作者个人的情感倾向。然而这依然是一本好书，它给如何看待历史提供了新思路——“历史是毫无用处的，因为我们根本不会从中得到任何教训。”它也告诉我们如何看待人类：“人类（智人）并不特殊，也并不唯一”。 能在这么短的一本书里，讲清楚智人的发展史，我觉得是很了不起的，广度是绝对够了，所以它更适合入门，其中穿插的进化心理学、社会心理学、生物学等等历史以外的知识，限于篇幅在深度上也没办法涉猎那么深。 最后，历史是“巧合”和“必然”的联合产物，所以书的最后一部分谈智人未来发展时作者也提出了很多有趣的设想，让我觉得自己可能出生在了一个刚刚好的年代——我们不受制于过去的愚昧偏见和低下的生产力，这个社会也暂时还没有因为生物工程产生可怕的阶级分层（参考大刘的《赡养人类》以及赫胥黎的《美丽新世界》）。我时常在害怕，从现代社会的生活模式其实已经可以窥见未来世界的一角，比如“奶头乐理论”，我们先不论该理论的真假，但短视频文化和各种手游的兴起带来的降智已经显而易见；希望自己能永远保持警惕，不要汩没到十字街头的影响里去才好。 点评:★★★★★]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>尤瓦尔·赫拉利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人类群星闪耀时》笔记]]></title>
    <url>%2F2020%2F01%2F16%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%BE%A4%E6%98%9F%E9%97%AA%E8%80%80%E6%97%B6%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《人类群星闪耀时》 茨威格 ◆ 1 不朽的逃亡者 而当麦哲伦1520年穿越这片水域之时，竟然神奇地没有遭遇恶劣的天气和暴风，所以他们称其为“太平洋” 资本主义萌芽：承认自己无知，并开始向外探索，资本家为了获得财富对船队投资，只要回来一艘就赚翻了。（吗（《基督山伯爵》的设定可真带感 还有为了逃避债主的负债人、为了摆脱悍妇的丈夫，所有那些铤而走险的匪徒、生活潦倒的穷光蛋、身有烙印的枉法之徒和被警察追捕的通缉犯，都来报名参加远航队。好一伙乌合之众，他们孤注一掷，期待着一夜暴富。为达目的，不管是怎样的暴力和罪行，他们都无所顾忌。 一个人生命中最大的幸运，莫过于在他的人生中途，即在他最富创造力的壮年之时，发现了自己的人生使命 没错，当他终于伫立在山顶，眼前真的是一片非凡的景象。在地势逐渐倾斜的山峰下方，在郁郁葱葱的山丘后面，是一大片望不到尽头的大海，波光粼粼，明媚耀眼。这就是那片大海，那片陌生的大海，那片尚未为人所知的大海，那片传说中的大海，迄今为止它只萦回于人们的梦里，而从未有人亲眼见过它。 1513年9月25日，就在这一天，人类知道了地球上迄今未知的最后一个海洋。 这是人类的第一双眼睛，它们曾同时看到过环抱我们地球的两个大洋。 ◆ 2 千年帝国的陷落 奥斯曼帝国攻陷君士坦丁堡从而终结东罗马帝国的1453年。 一切正在准备战争的强权统治者都一样，只要还没有完全准备就绪，他们总是竭力散布和平论调 人的意志又一次使不可能的事情成为可 但是，穆罕默德也是个幻想家，不过，他属于另一种类型，一种相当稀有的类型。他十分擅长通过自己的意志把幻想变成现实。 这段读起来实在悲壮，我甚至脑补出了某个中二的罗马少年一边说“我要与人类为敌”一边暗自打开了凯尔卡边门的样子（中毒至深 人类将永远无法完全确知，在那命运攸关的时刻，那扇敞开的凯尔卡门带来了怎样的灾难；而在罗马城、亚历山大城和拜占庭被洗劫一空之后，人类的精神世界又遭受了多少损失。 欧洲万分恐惧地认识到，由于他们的麻木不仁，一股天谴般的破坏力量竟从那座被遗忘的小门——不祥的凯尔卡门闯了进来，这股暴力将要遏制和束缚欧洲达数百年之久。然而历史犹如人生，业已失去的瞬间不会因为抱憾的心情而重返，仅仅一个小时所贻误的东西，用千年的时光也难以赎回。 ◆ 3 亨德尔的复活 这一段无论是原文还是翻译都是上乘，虽听不见音乐，但却能体会到那种史诗感和戏剧感——一个重病缠身，双目失明的老人，在自己生平最爱的清唱剧现场，和着旋律高唱出声。 我从冥界回来了。”乔治·弗里德里希·亨德尔挺着宽阔的前胸，伸出有力的双臂，自豪地对伦敦的詹金斯医生说。 在读这一篇的时候，我打开了《弥赛亚》作为bgm，而巧合的是，在读这一段时，序曲终了，我听到了那一句“comfort ye”，不得不说这一瞬间我体会到了亨德尔当时看到这行字的心情，一种顿悟。 Comfort ye”，这就是剧词的开头。 刚刚读完和体会到第一句，亨德尔的耳边仿佛已经听到了它的音乐，各种器乐和声乐在飘荡、在呼唤、在咆哮、在歌唱。啊，多么幸运，堵塞灵魂的大门已然开启！他感觉到，自己又听到了音乐！ 只有饱经忧患的人才懂得欢乐；只有经过磨难的人才会预感到仁慈的最后赦免；而他就是要在众人面前证明：经历了死亡的人是可以复活的。 ◆ 4 一夜天才 “一夜的诗人”这个称号本身就已足够浪漫啦 同代人往往很难一眼就看出一个人的伟大或一部作品的伟大，甚至连市长夫人也并未意识到这是一个非凡时刻。 这首歌既不适合女高音独唱家演唱，也不适合男高音独唱家演唱，它适合成千的群众齐唱。 这个半瓶子醋曾擅自闯进不朽者的行列，对此，命运没有原谅他。这个小人物后来干过各色小行当，有的并非十分干净，他困苦地度过了自己渺小的一生。卡诺￼和后来的拿破仑曾出于同情想帮助他，但都没有成功。那一次偶然的机缘曾使他当了三小时的神明和天才，然后又轻蔑地把他重新抛回到微不足道的卑微地位，这是多么残酷，残酷的命运也使得他的性格像中了毒似的变得无可救药地乖戾，他对所有的当权者都愤愤不平、牢骚满腹。 歌而本人却极不出名的作者，终于得以在那个曾让他感到失望的祖国的这块荣誉墓地里长眠，而他仅仅只是一夜的诗人罢了。 ◆ 5 决定世界的一分钟 有时候——这是世界历史上最令人惊奇的时刻——命运之线会在某个瞬间掌握在一个窝囊废手中。 因为伟大事业降临到渺小人物的时间，仅仅是短暂的一瞬。 ◆ 6 年老与爱情 虽然倾慕没有界限，但是爱情总有终点。 ◆ 12 封闭的列车 恰恰总是那些读了很多东西、学了很多东西的孤独的人，往往是世界革命化进程中最危险的人 ◆ 13 演讲台上的头颅 这一章真实得让人恨起了屋大维；但是要认识到一点，那就是：战争都是血腥与残酷的，绝对的力量面前，没有人文主义，更不存在自由；西塞罗救不了罗马，因为人民太弱小了。 独裁是危险的，改革亦是如此。 而且，当一个民族总是以暴力夺取其他民族的自由的时候，这个民族也就会在神秘的复仇之中被孤立，从而失去自己最神奇的力量。 既没有完全下定决心，直面自己的命运。也没有完全下定决心，逃避自己的命运，他似乎无意地以这种随时准备死去的状态实现自己的座右铭，也就是他曾在《论老年》中写下的座右铭：一个年老之人，既不应该寻求死亡，也不应该推托死亡；不管死亡什么时候到来，人们都应该顺其自然地迎接它。对于坚忍不拔的人来说，不存在可耻的死亡。]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>茨威格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10+mx150安装cuda——让你的小笔记本也能显卡加速]]></title>
    <url>%2F2019%2F11%2F29%2Fwin10%2Bmx150%E5%AE%89%E8%A3%85cuda%E2%80%94%E2%80%94%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%B9%9F%E8%83%BD%E6%98%BE%E5%8D%A1%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[thinkpad t480s（win10家庭版）安装cuda和cudnn,给pytorch计算加速。打开核显笔记本的的正确用法。 多查一些教程就很难踩坑了，我大概一个小时装完，极限操作。 cuda 安装 查阅你的显卡支持的版本。 控制面板 —&gt; NVIDIA控制面板 —&gt; 系统信息 —&gt; 组件 确定NVIDIA GeForce MX150支持cuda10.1版本。 去官网下载相关的安装程序 2019年11月，nvidia官网默认下载cuda10.2,一定要注意选择你刚刚查询到的cuda版本，否则会产生不兼容问题。例如我自己搜索了10.1版本下载。 建议选择下载到local而不是network，使用迅雷下载还比较快。 cuda是被直接默认安装到系统盘的，一开始要求你解压的文件夹只是一个临时文件夹，安装完之后会被删除。 检查安装是否成功 在cmd中输入nvcc -V查看。 cudnn安装 cudnn是基于cuda的加速器，可提升原有的gpu算力至1.5倍。是nvidia专门开发的，在下载前会要求你填一个小问卷，选择使用理由什么的。 这一步选择对应的cuda版本即可，下载后得到一个zip文件，里面包含了bin、include、lib三个文件夹，直接复制到cuda的安装文件夹下即可。 nvidia-smi查看显卡使用情况 上面这两步实现之后，还可以添加C:\Program Files\NVIDIA Corporation\NVSMI\到系统变量中，这样下次就可以直接在cmd中输出nvidia-smi查看显卡占用情况了。 pytorch+gpu安装 选择相应的pytorch版本 pytorch+gpu安装要去官网选择对应的OS系统、python版本以及cuda版本。 清华源加速 使用默认源下载会很慢，推荐使用conda的清华源镜像，cmd中配置以下命令即可： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yesconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda install pytorch torchvision cudatoolkit=9.0 （版本号从https://pytorch.org/resources上，查找对应版本）]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cuda</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea 里跑通一个example要花多久?]]></title>
    <url>%2F2019%2F06%2F03%2Fidea-%E9%87%8C%E8%B7%91%E9%80%9A%E4%B8%80%E4%B8%AAexample%E8%A6%81%E8%8A%B1%E5%A4%9A%E4%B9%85%2F</url>
    <content type="text"><![CDATA[2天（手动微笑脸） 主要是idea环境配置真的让人想哭。 在project structure里，有一些包是不能手动导入的，必须要选择了然后打包进去（可能这样在打jar包的时候更合适一点吧~）]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala学习]]></title>
    <url>%2F2019%2F06%2F01%2Fscala%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Scala基本语法 scala引用 导入单个包 在导入的时候重命名 在导入的时候隐藏成员 12345import java.awt.&#123;Color,Font&#125;//重命名成员import java.util.&#123;HashMap =&gt; JavaHashMap&#125;// 隐藏成员import java.util.&#123;HashMap =&gt; _, _&#125; // 引入了util包的所有成员，但是HashMap被隐藏了 scala中一切皆对象 一切皆对象的意思是，在scala中，即使是数字，也可以直接调用方法。比如： 11._toString Scala变量 变量声明 var声明变量 val声明常量 变量类型引用 scala中可以不用先声明数据类型，是自己推断出来的。 不过要注意的是，如果没有指定数据类型，那么一定要给声明的变量赋初值。 Scala访问修饰符 public类 private类 Scala的匿名函数 以=&gt;的形式可以定义一个匿名函数，如下： val multiplier = (i:Int) =&gt; i * 10]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>saprk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[t检验和F检验的区别]]></title>
    <url>%2F2019%2F04%2F14%2Ft%E6%A3%80%E9%AA%8C%E5%92%8CF%E6%A3%80%E9%AA%8C%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[近日重读统计学习方法。 t检验用的t统计量多用在单变量上；F检验用的F统计量，多用在多变量上。（邹至庄检验、变量是否显著的检验都是基于F-test提出的。） F统计量的自由度：是两个卡方分布除以自由度之后的比值。分子的自由度为d1d_1d​1​​，分母的自由度为d2d_2d​2​​，则该统计量就服从自由度为(d1,d2)(d_1,d_2)(d​1​​,d​2​​)的F分布。]]></content>
      <categories>
        <category>统计</category>
      </categories>
      <tags>
        <tag>假设检验</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁金服 机器学习算法岗 菜鸡的面经]]></title>
    <url>%2F2019%2F04%2F13%2Fantifin_interview%2F</url>
    <content type="text"><![CDATA[时间线： 20190401 接到第一个电话，约了第二天正式面试，并且给我发了一份笔试题。是一个二分类问题，为期一周。 20190402 一轮电面一轮视频面。 20190405 中午二面，晚上三面，面试官有说自己是交叉面。 20190409 HR面。 20190412 收到意向书。 所以是4轮技术面试+一轮笔试+HR面。前后也就10天，效率非常高。 不过据我猜测，第一轮电话面试应该是其他方向的，看我有经验所以过来面一下，然后发现我技能并不合适，不算在整个面试流程内，所以理论上我应该只走过三轮正式面试。 我本身其实菜菜的，身边比我厉害的大佬也有很多，加入蚂蚁真的靠运气，以后会继续努力，争取成为合格蚂蚁人。 4.2电话面 首先第一轮电话面试，面试官主要问了我一些图像类（尤其是深度学习方向）的内容。我感觉的确是技能点不适配，这个面试官需要一个动手能力很强的人，快速复现代码能力要很强，全程大概30min，问题如下： 你有自己实现过网络结构吗？ 讲一下faster-RCNN，它的损失函数是什么样的？ 我看faster-RCNN只看清楚了它的网络框架结构，损失函数那里没有自己推过所以忘记了。听到这里就疯狂去翻笔记，但是没有翻到，对面没有继续追问。 后来我自己看了一下损失函数。Faster-RCNN的损失函数分为bounding-box regression的损失和前景与背景的分类错误损失。 做过哪些特征工程？ 让你实现max-pooling和RELU层，他们的先后顺序是什么样的？ 这个问题我凭直觉是max-pooling在前，RELU在后，原因没有说明白。面试官告诉我原因就是这样安排减少了计算量。恍然大悟：有道理啊！！ 你一个学统计出身的，这些知识是从哪儿学的？ 从coursera上学了不少。他问我有证书吗，我说有，然后他也没再问了。 你有没有自己实现过一个项目，从标签的收集到网络结构的实现都进行过？ 目前在做一个主题情感分类的项目，标签是半自动化半监督去打的，写过LSTM，下一步打算试试bert。他没再多问。 你pyTorch实现过网络吗？ 拿pyTorch实现过最简单的BP神经网络。对面说，啊那算个啥啊，连个反向求导都没得。 ……对不起我真是太菜了TAT 有什么问题要问我吗？ 心想凉都凉了，面试表现就不问了吧，大家心知肚明……就问了他：学统计是不是在深度学习上没什么优势？ 他说：“？？？我就是学统计的。”，我：“那你为什么从统计转到深度了，我觉得统计和深度的交叉很小啊”，他说因为有需求啊……他说他本身在kaggle上是个大牛，也打过比赛，是传统机器学习出身。你不会的东西去学就行了，没啥的。 然后电话面试就结束了。这位面试官可能更看重实践和动手力，get your hands dirty。我感觉应该是技能不适配，凉凉。 没想到刚结束，之前联系我的面试官就给我发微信，说十五分钟后再和我聊一聊，抖擞精神再战。 4.2视频面试 15min后开始视频面，这个面试官应该是我的mentor,主要问的统计问题，大概聊了70min，到晚上快11点。可见蚂蚁的工作强度有多大_(:з」∠)_ 一上来问了三道概率题。 假设有两个人一前一后抛一枚硬币，谁先扔到正面谁就赢了，问第一个人赢的概率是多少？ 这是一个等比数列求和的问题。第一个人只可能在1,3,5,7……次赢，所以概率为： P=(12)+(12)3+(12)5+...+(12)∞P=(\frac{1}{2}) + (\frac{1}{2})^3+(\frac{1}{2})^5 +...+(\frac{1}{2}) ^{\infty} P=(​2​​1​​)+(​2​​1​​)​3​​+(​2​​1​​)​5​​+...+(​2​​1​​)​∞​​ 有一个人在等车，总共两辆车，他们都服从0~10上的均匀分布，问这个人等车的期望是多少。 可以假设y=min(x1,x2)y = \min(x1,x2)y=min(x1,x2)，那么 P(Y&gt;y)=P(x1&gt;y)∗P(x2&gt;y)=(1−y10)2P(Y&gt;y) = P(x_1&gt;y)*P(x_2&gt;y) = (1 - \frac{y}{10})^2 P(Y&gt;y)=P(x​1​​&gt;y)∗P(x​2​​&gt;y)=(1−​10​​y​​)​2​​ 有个人面前有三条路，他每次都有相同的概率选择走哪条路。选第一条路3个小时走出去，选第二条路4个小时回原点；选第三条路5个小时回原点。问这个人走出去时间的期望。 E(x)=13∗3+13∗(E(x)+4)+13∗(E(x)+5)E(x) = \frac{1}{3}*3+\frac{1}{3}*(E(x)+4)+\frac{1}{3}*(E(x)+5) E(x)=​3​​1​​∗3+​3​​1​​∗(E(x)+4)+​3​​1​​∗(E(x)+5) 一三道题我思路还是很清晰的，但是第二道题没答出来。对面给了一点提示，我把式子写出来了，积分没算出来。后来面试结束以后我又给他发了答案。 按照熟悉度简述一下你最熟悉的机器学习方法，至少10种。 实话实说，线性回归&gt;logistic回归&gt;SVM&gt;K-NN&gt;决策树&gt;随机森林&gt;XGBoost&gt;贝叶斯&gt;K-means&gt;PCA&gt;…… 他说停，你讲一下PCA主要是做什么的，怎么求的。特征值含义是什么等等。 接着又问，你写一下决策树的伪代码。（这个我没写出来- -） 再基于决策树讲一下你怎么实现一个随机森林。 我这里讲错了，对面把我教育了一番，然后给我讲了一下随机森林的原理。 你讲一下GBDT，XGBoost的改进在哪里。 XGBoost为什么可以实现并行计算？ 知道陈天奇有近似优化算法，但是没有看懂。 他说那不行啊，你这个地方还是得看懂了再说。 后来就开始瞎聊了，他问我有什么要问他的，我说你觉得我还有哪里可以提升吗？他就说你统计还行，但是算法那一块儿要加强，一定要把项目内容了解透彻，逻辑要清楚。 整体来说，这个老大特别特别特别和蔼，给人一种很想让你过的感觉。他后面也给了我不少指导意见，对我帮助很大。 4.5蚂蚁二三面总结 二三面都非常快，中午二面，晚上三面， 二面 二面的面试官几乎没有问技术问题。时间也就20min 你讲一下你的项目吧； 讲一下GBDT和随机森林的区别（我答得很浅，说一个是boosting,一个是bagging，他没有追问） 愿意在杭州工作吗。 有什么问题要问我吗？ 三面 三面自我介绍是交叉面，问得不难，30min左右。 你讲一下你最有挑战难度的项目。 列举你知道的五种二分类方法，讲一讲他们之间的区别。（这个我自觉答得挺好的，面试官好像很满意) 讲一下faster-RCNN的原理。如果有时间的话，你会怎么改进你的算法？ 有什么问题要问我吗？ HR面 周二早上就接到HR电话了，20min，非常常规，聊聊你的家庭，你的兴趣爱好，日常都是怎么减压的等等。 还有就是，要求你一天5天都实习你觉得你OK吗，我说我可以我可以，我翘课也可以！！！ 总结来说HR面舔狗一点，应该不会挂的。 总结 我是周六（4.6）把笔试题交上去的，那个时候我所有的技术面就已经结束了，不是很清楚这份笔试题在整个流程当中的作用。 交完笔试题后，一直没收到回复，HR面后也没有消息，慌得不行，想着还是要争取一下，所以4.11号（周四）整理了一下之前做的东西，又给一面面试官发了一份新的，面试官先肯定了我的笔试结果，并让我好好准备大集团笔试，还给我发了一份攻略。 结果当天晚上他直接口头告知我已经处在offer流程，不用再做笔试了，并问我什么时候可以过去实习等等。于第二天（周五）晚上收到意向书。 以上差不多就是我蚂蚁面试经验了。一路走来感觉还是比较顺利的，有些受之有愧。虽然阿里是BAT的龙头老大，但我觉得阿里的面试官一点都没有大厂的架子，真的特别特别和蔼……总结下来自己还有很多需要努力的地方，所以就继续加油吧~！]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openpose踩坑记]]></title>
    <url>%2F2019%2F02%2F27%2Fopenpose%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[暑假时第一次接触深度学习，老大直接丢给我openpose的复现，因为是从小白学起的，配环境的时候踩了很多很多坑，本来拉下来的是纯净的ubuntu16.04系统，一步一步从0开始配置的环境。但是令人沮丧的是，最终CUDA还是无法运行，所以我放弃抵抗，拉了前人搭好Detectron框架……但是中间一些步骤我觉得还蛮有意义的，特此记录。 docker拉的纯净的cuda+ubuntu16.04 我用的是nvidia/cuda：8.0-cudnn5-runtime-ubuntu16.04镜像: 1sudo docker pull nvidia/cuda：8.0-cudnn5-runtime-ubuntu16.04 新装的ubuntu，连apt-get都没有，所以先apt-get update 装git/vim：apt-get install git(这一步是为了git clone openCV用的，如果之前有了openpose的话，就不需要了（但是装个git总是好的） 接下来是装openpose的附属了~ 3. 装cmake-gui: apt-get install cmake-qt-gui 4. 再装lsb-release&amp;wget(因为作者给的sh里面用到了~） 123apt-get install lsb-releaseapt-get install wgetapt-get install apt-utils #(不知道什么玩意儿但是被报错了……） 接下来，首先从openpose的官方git上把文件夹git clone下来，接着cd openpose，进行如下操作： 装cuda：ubuntu/install_cuda.sh（注意要把sudo给删了~） 装cuDNN5.1: ubuntu/install_cudnn.sh 装AMD GPU version prerequisites：apt-get install libviennacl-dev 装caffe：ubuntu/install_cmake.sh 装openCV：apt-get install libopencv-dev 对了，还要装pip apt-get install python-pip bulid环境。在ubuntu系统下，可以不依靠cmake-gui,用他们给的makefile.txt即可： 首先，在目录下创建一个bulid文件夹， cd bulid 运行：cmake ../ 这样就得到了Cmakefiles了~ 编译阶段还蛮累（耗时间）的，不过一次编译终生享用，我之前已经cmake过，获得了CmakeFiles。所以，如果需要使用的话，后面的操作只需要直接在build文件夹里运行：make 就可以啦~ 试下能不能运行： 进入到openpose目录下，运行 12./build/examples/openpose/openpose.bin --video examples/media/video.avi --display 0 --write_video output/asia_office_out.avi./build/examples/openpose/openpose.bin --image_dir examples/media/ --write_images output/images --display 0 === 分割线 === 执行到这一步，我真的觉得胜利在望了！！ 然而，非常蛋疼的问题出现了。 demo报错，还是unknown error。真的查了一天都没查出来什么原因。 后来加了一个权限：让这个docker容器真的可以用硬件跑： 1sudo nvidia-docker run --privileged=true --name openpose_tutorial_wk 就是这个privileged=true啦。 然后它换了一个报错方式： 1Failed to initialize NVML: Driver/library version mismatch (╯‵□′)╯︵┻━┻ 但是好歹好像可以解决了（至少不是unknown了……） 上网，查，怎么换驱动: 首先，卸载现有的nvidia驱动： 12apt-get purge nvidia-*apt-get remove --purge nvidia-\* 接下来运行： 1apt-get install software-properties-common（为了让add-add-apt-repository可执行） 接着就可以用add-apt-repository： 1add-apt-repository ppa:graphics-drivers/ppa &amp;&amp; sudo apt update 一定要记得update!（血泪教训） 最后，apt install nvidia-390. ====你以为以上这些解决了吗？===== ====并没有，最后是docker pull了其它的镜像过来的=== ====就这样吧，还是现成的舒服.jpg==== 试下python API： （1）首先安装依赖包，按照网上教程，装了一堆： 1apt-get install python-numpy python-scipy python-matplotlib python-sklearn python-skimage python-h5py python-protobuf python-leveldb python-networkx python-nose python-pandas python-gflags cython ipython 如果报错，先apt update一下。 然后再装： 1apt-get install protobuf-c-compiler protobuf-compiler 最后，进入caffe的目录，执行： 1apt-get install gfortran （没有fgortran这个编译器可能会报错，所以先装好） 接下来再执行caffe给的依赖包。 1for req in $(cat requirements.txt); do pip install $req; done （2）改makefile.list里面的3个地方，因为我装openpose的时候用的是他们给的caffe,而他们的caffe默认是不编译python的： ① 252行：: option(BUILD_PYTHON &quot;Build OpenPose python.&quot; OFF)的OFF改成ON。 ② 675行：-DBUILD_python=OFF，改成ON。 ③ 680行：-DBUILD_python=OFF，改成ON。 （3）然后要记得改系统变量，否则在python中import caffe会出错的。这个地方比较麻烦，因为我把openpose装在自己的文件夹里了，导致这个docker其实不是很完善（哭泣)，一会儿我会重新装一下的。 ① 首先：vim /etc/profile ② 在末尾添加： 1export PYTHONPATH=/path/to/caffe/python:$PYTHONPATH 保存后，再执行： 1source /etc/profile # 使之生效 这些都准备好了之后，试试给的两个sample： 123cd build/examples/tutorial_pythonpython 1_extract_pose.pypython 2_pose_from_heatmaps.py 注意因为是在docker里面跑的，所以要把有关什么im.show这种都注释掉，不然会报错。 ===========ヾ(@▽@)ノ装完啦散花============= 最后一个坑：如何在docker容器中显示？]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNN VS CNN]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%90%B4%E6%81%A9%E8%BE%BERNN%2F</url>
    <content type="text"><![CDATA[写一点个人理解吧。 CNN：它是以“层”（layer)为单位的，每一层的结构可以完全不一样。常见的CNN层有卷积层、池化层、softmax层、池化层；这些基础层之上还有诸如ResNet的远连接，GoogLeNet的Inception层，用来实现一些特定的功能（深层网络、多尺度特征提取等）。 RNN：“层”的概念被弱化了，与之相对突出的是“单元”（cell)的概念。之所以叫Recurrent，就是一个重复的cell自己连自己，每一层的输入尺寸除了新加入的x以外，还有上一个时期的激活值a。这样它就“记住了”在一串序列中之前传进来的信息。进阶的RNN则通过“门”（Gate)来实现特定的功能。具体的内容我还没有非常理解，只实现了一下LSTM的网络架构。 RNN的经典网络 经典的RNN网络比如LSTM和GRU，通过加入控制门，预防梯度消失问题。让非常久远以前的信息也可以被记住，传给后续的单元。 这个概念有点像resnet，把好几层以前的输出传给后一层，但是相比于ResNet人工设计该层用哪些层的前续信息，LSTM中则是通过训练参数，交给网络自行决定在哪个时间“打开”特定的功能。 用LSTM进行生成序列模型时，一般用前一期的内容去预测后一期的音符。]]></content>
  </entry>
  <entry>
    <title><![CDATA[LSTM中sigmoid和tanh函数的区别]]></title>
    <url>%2F2019%2F02%2F17%2FLSTM%E4%B8%ADsigmoid%E5%92%8Ctanh%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[tanh是用于激活函数的，将实数域中的值映射到[−1,1][-1,1][−1,1]中，可以用其他激活函数替代; sigmoid是用于控制Gate的，将实数域映射到[0,1][0,1][0,1]上，所以sigmoid比较合适。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（六）-图]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E5%85%AD%EF%BC%89-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[本章重点 图的Python实现 图的概念 完全图：任意两个顶点之间都有边的图（有向/无向）。 n个顶点的无向完全图有 n×(n−1)/2n\times \left(n-1\right)/2n×(n−1)/2个边 n个顶点的有向完全图有 n×(n−1)n\times \left(n-1\right)n×(n−1)个边 简单路径：起点和终点外的其他顶点均不相同，成为简单回路。 有根图：顶点v到图G中其他每个顶点均有路径，就称G为有根图，顶点v为图G的一个根。 连通无向图：无向图中的任意两个顶点都连通 强连通有向图：有向图G中两个顶点两个方向的路径都存在，称G为强连通有向图。 最小连通图：去掉任何一条边都不再是有根图。 子图、连通子图 最大连通又叫做 连通分量，如果G连通，那么G将只有一个连通分量；反之，它的连通分量就多于一个。 带权图和网络——邻接矩阵和邻接表 邻接矩阵因为要占n2n^2n​2​​的空间，所以可能带来空间的浪费。所以，采用邻接表的形式。 邻接矩阵和邻接表的python实现 图的遍历 图的遍历，指的是按照某种方式系统地访问图中每个顶点，而且仅访问一次的过程。也称为“图的周游”。 深度优先遍历 从指定顶点v出发，标记为已访问； 检查v的邻接结点，从中选择一个未访问的顶点，进行深度优先搜索（一种递归算法）；不存在这种邻接顶点时，就回溯； 上述操作反复进行，直到v出发可达的所有顶点都已经访问（递归） 如果图中还有未访问的的顶点，就选出一个未访问的顶点，由它出发重复上述操作，直到所有结点都访问结束了。 上面这种形式的操作就叫做Deep-First Search(DFS),DFS序列。它不唯一；但是，如果规定了邻接点的顺序，它就是唯一的。 宽度优先搜索 访问顶点viv_iv​i​​,将其标记为已访问; 访问v的所有相邻结点vi0,vi1...vim−1v_{i_0},v_{i_1}...v_{i_{m-1}}v​i​0​​​​,v​i​1​​​​...v​i​m−1​​​​，]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS + docker快速上手hadoop(linux)]]></title>
    <url>%2F2018%2F12%2F03%2FVPS-docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bhadoop%2F</url>
    <content type="text"><![CDATA[本篇不是教程！不是教程！不是教程！算是一个资源汇总，一小时内搞定hadoop集群，上手hive命令不是梦。 前提是： 装好了docker，docker安装文档 装好了docker-compose（1.10.0版本及以上），docker-compose的官方安装文档 拥有git账号； 拥有docker hub账号； 一个至少2G内存的linux虚拟机/服务器。（内存不够的话，跑hive可能会被强制kill掉） 废话与背景介绍 听闻hadoop环境配置令人作呕，这时候用docker起hadoop，作为练手就非常合适了。 上手只是玩一玩，熟悉一下hadoop架构，如果真的有大量数据处理需求的话，还是要老老实实自己搭集群哦。 预备：Xshell连接服务器 如何利用Xshell链接远端服务器。点这里 Xshell快速上传本地文件，点这里 纯hadoop集群搭建 Docker Hub上排名第一位的是uhopper/hadoop,利用docker-compose实现hadoop集群的部署。 无脑拉一个前人的工作下来，推荐这位小哥的博客，博客里提供了git clone的地址。 查看服务器中namenode的IP地址，在命令行中输入： 1$ docker inspect namenode | grep IPAddress 会得到输出结果，我的结果是： 123"SecondaryIPAddresses": null, "IPAddress": "", "IPAddress": "172.18.0.2", 利用Xshell的隧道功能，可以将服务上的172.18.0.2/50070映射到本地的localhost，方便查看集群状态。 上手hive 该项目和上面hadoop的docker是完全独立的，上述的hadoop的docker-compose只是搭建了一个干净的hadoop集群，而下面的docker则进一步实现了hive。 这里给出一个人气很高的docker-hive仓库 首先，拉取仓库：git clone https://github.com/big-data-europe/docker-hive.git 进入文件夹中：cd docker-hive 起docker-compose： docker-compose up -d (作者还提供了其他几种方案，可以去github上自己阅读) 测试: 12$ docker-compose exec hive-server bash# /opt/hive/bin/beeline -u jdbc:hive2://localhost:10000 如果没有报错，说明hive已经成功运行了，尝试输入： 1&gt; CREATE TABLE pokes (foo INT, bar STRING); 创建表格，句末分号不要丢。 hbase hbase后续再更新]]></content>
      <categories>
        <category>日常瞎玩</category>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tricks]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%AD%97%E5%85%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[没有条理，看到就记录一下。 dict 迭代方法 使用dict.items同时迭代字典的KEY和内容。 12for name, value in dict.items(): …… dict.values()用来迭代字典的名字，但是python版本的问题导致values顺序不能保证，所以如果有明确对应需要的话，一定要用键值对的方式批量赋值。 直接迭代dict，得到的内容是一个一个的小字典： 12for d in dict: print(d["keyname"]) json json也是一种存储文件的形式，有几个比较常见的函数如json.dumps(),json.loads() 1234567x = &#123; "name":"John", "age":30, "city":"New York"&#125; # 这是一个字典的形式y = json.loads() # 得到的是一个python dictionaryz = json.dumps() # 得到的是Json string python的迭代器iter()和next() 123456mytuple = ("apple", "banana", "cherry")myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit)) 这样一波操作可以把里面的所有元素都打印一遍。 numpy numpy的slice的改变是会改变原有的内容的。 pandas pd.qcut(x, q, labels=None, retbins=False, precision=3, duplicates='raise')返回按照顺序分割好的区 sklearn 机器学习方向 标签转换 sklearn.preprocessing.OneHotEncoder()以及sklearn.preprocessing.LabelEncoder() LabelEncoder底下有一个fit_transform超级好用！ 1dataset['Sex_Code'] = label.fit_transform(dataset['Sex']) 这个东西搭配pandas的pd.get_dummies食用效果更佳 结果输出和比较 sklearn.metrics metrics.accuracy_score() metrics.confusion_matrix(y_true, y_pred, labels=None, sample_weight=None)用来计算混淆矩阵，但是要画出来还是需要一点点的加工。 现在还可以用voting来进行集成。一般来说，用很多的分类器，最后使用voting来打比赛会更合适。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Pyhton（五）-二叉树和树]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E4%BA%94%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树也是一些基本元素的汇集，树形结构也是由结点和结点之间的连接关系构成的，但是其结构和线性结构表不同，最重要的特征有： 如果一个结构不空，则其中存在着唯一的起始结点，称为“树根”。 按结构的连接关系，树根外的其余结点都有且只有一个前驱，但它可以有0个或者多个后继。并且在非空的树结构中一定有些结点并不连接到其他结点。 结构里的所有结点都在树根结点通过后继关系可达的结点集合里。即从树根结点出发，若干次后继关系可以到达结构中的任何一个结点。 结点之间的联系不会形成循环关系 这种结构里的任意两个不同节点出发，通过后继关系可达的两个结点集合，或者互不相较，或者一个集合是另外一个集合的子集。 本章重点： 利用堆结构实现优先队列 哈夫曼树 二叉树： 概念：二叉树是一种树形结构，它的每个结点至多关联到两个后继结点，即它的关联结点数可以为0，1或者2；另外，一个结点关联的后继结点明确地区分左右，或者为左关联结点，或者为右关联结点。 概念和性质 定义 二叉树是结点的有穷集合，这个集合或者是空集，或者是其中有一个称为“根节点”的特殊结点，其他结点分属两棵不相交的二叉树。这两棵二叉树分别是原二叉树的左子树和右子树。 几个基本概念 不包含任何结点的二叉树称为 空树。只包含一个结点的二叉树是一课 单点树。 父节点&amp;子节点 结点的子结点个数称为该结点的度数。二叉树树叶结点的度数为0，分支结点的度数为1或者2； 路径、结点的层和树的高度 一课二叉树的高度（也称为深度）就是树中结点的最大层数（即这棵树里的最长路径的长度）。树的高度是二叉树的整体性质，只有根节点的树高度为0，一般不讨论空树的高度。 二叉树的性质 二叉树最重要的性质就是： 树的高度和树中可以容纳的最大结点个数之间的关系。树的高度类似于表长，是从根结点（首结点）到其他结点的最大距离。 性质1：在非空二叉树第i层中至多有2i2^i2​i​​个结点 性质2：高度为h的二叉树至多有2h+1−12^{h+1}-12​h+1​​−1个结点（h≤0h \leq 0h≤0）（把每层结点个数加起来就好啦~~） 性质3：对于任何非空二叉树T，如果其中叶结点的个数n0n_0n​0​​，度数为2的结点个数是n2n_2n​2​​，那么n0=n2+1n_0 = n_2 + 1n​0​​=n​2​​+1 满二叉树和扩充二叉树 满二叉树：如果二叉树里的所有分支结点的度数都是2，则称它为一棵满二叉树。 满二叉树是一般二叉树的一个子集； 性质4：满二叉树里的叶结点比分支结点多一个。（根据性质3的推论） 扩充二叉树：对二叉树T，加入足够多的新叶结点，使T的原有结点都变成度数为2的分支结点，得到的二叉树称为T的扩充二叉树。扩充二叉树中新增的结点称为其外部结点，原树T的结点称为其内部结点。空树的扩充二叉树规定为空树。 性质5：扩充二叉树的外部路径长度EEE是从树根到树中各外部结点的路径长度之和，内部路径III长度是从树根到树中各内部结点的路径长度之和。如果该树有n个内部结点，那么E=I+2×nE = I+2 \times nE=I+2×n 完全二叉树 对于一棵高度为h的二叉树，如果其第0层到第h-1层的结点都满了，则所有结点在最左边连续排列，空位都在右边，这样的二叉树就是一棵完全二叉树。 性质6：n个结点的完全二叉树高度h=[log2n]h = [log_2n]h=[log​2​​n]，即不大于log2nlog_2nlog​2​​n的最大整数。 性质7：如果有n个结点的完全二叉树的结点按层次并按从左到右的顺序从0开始编号，对任意结点i(0≤i≤n−1)i(0 \leq i \leq n-1)i(0≤i≤n−1)都有： 序号为0的结点是根 对于i&gt;0,其父节点的编号是(i−1)/2(i-1)/2(i−1)/2 若2×i+1&lt;n2 \times i + 1 &lt; n2×i+1&lt;n，则它的子结点序号为2×i+12 \times i + 12×i+1，否则他没有左子结点； 若2×i+2&lt;n2 \times i + 2 &lt; n2×i+2&lt;n，其右子结点序号为2×i+22 \times i + 22×i+2，否则它没有右子结点。 通过性质7，可以方便的存入一个表或者数组，直接根据元素下标就能找到一个结点的子结点或者父节点。 根据性质1，二叉树的第i层有2i2^i2​i​​个结点，根据性质2，前i−1i-1i−1层结点如果全满的话，共计有2i−12^i - 12​i​​−1个。由于根的下标是0，第i层元素从下标2i−12^i - 12​i​​−1的位置开始存放，连续2i2^i2​i​​个元素属于这一层。 这说明，从完全二叉树到线性结构有自然的双向映射，可以方便地从相应线性结构恢复完全二叉树。但是，一般二叉树就没有这种性质。 一般而言，对于n个结点的二叉树有如下情况（直观的看法）： 如果它“丰满且整齐”，即树中很少度数为1的分支结点，且最长路径的长度差不多。则树中最长路径的长度将为O(logn)O(\log n)O(logn) 如果它比较“畸形”，最长路径的长度可能到达O(n)O(n)O(n) 抽象数据类型 1234567891011ADT BinTree: BinTree(self, data, left, right) is_empty(self) num_nodes(self) #求二叉树的结点个数 data(self) # 获得二叉树根存储的数据 left(self) # 获得二叉树的左子树 right(self) # 获得二叉树的右子树 set_left(self, btree) #用btree去掉原来的左子树 set_right(self, btree) #用btree 代替原来的右子树 traversal(self) #遍历二叉树中各节点数据的迭代器 forall(self,op) # 对二叉树中的每个结点的数据执行操作op 遍历二叉树 每棵二叉树有唯一的根节点，从而将其看做这棵二叉树的唯一标识。 系统化遍历二叉树有多种可能的方式，有两种基本方式： 深度优先遍历：顺着一条路径尽可能向前探索，必要时回溯。二叉树里最基本的回溯情况是检查完一个叶结点，无路可走时回头； 宽度优先遍历：在所有路径上齐头并进。 深度优先遍历 按深度优先方式遍历一棵二叉树，需要做的事情是：遍历左子树，遍历右子树和访问根节点。分别用L/R/D表示这三项工作。 不同的处理顺序： 先根序遍历（DLR顺序），得到序列称为“先根序列” 中根序遍历（LDR顺序），也称对称序。得到的序列称为“对称序列” 后根序遍历（LRD顺序），得到的序列称为“后根序列” 由于二叉树的子树也是二叉树，所以一种具体的遍历顺序可以继续被运用到子树的遍历中，就形成了一种遍历二叉树的统一方法。 在遍历过程中遇到子树为空的情况，就立即结束处理并转去继续做下一步工作。例如，在先根序遍历中遇到左子树为空，就转去遍历相应的右子树。 宽度优先遍历： 宽度优先遍历没有办法写成一个递归过程。 二叉树的list实现 python的list或tuple都可以用来组合成这样的三个元素，两者的差异仅在于变动性。 设计和实现 基于list类型很容易实现二叉树，采用如下设计： 空树使用None来表示 非空二叉树用包含三个元素的表{d,l,r}表示，其中： d表示存在根节点的元素 l和r是两棵子树，采用与整个二叉树相同结构的list表示。 显然，这样做是把二叉树映射到了一种分层的list结构，每棵二叉树都有与之对应的递归结构的list。比如，我们可以把一课二叉树用list表示为： 12345["A",["B",None, None], ["C",["D",["F", None，None], ["G",None, None]], ["E",["I",None, None], ["H",None, None]]] 比如，我们可以给出下面几个基本操作： 1234567891011121314151617181920def BinTree(data,left = None,right = None): return [data, left, right]def is_empty_BinTree(btree): return btree is Nonedef left(btree): return btree[1]def right(btree): return btree[2]def set_root(btree, data): btree[0] = datadef set_left(btree, left): btree[1] = datadef set_right(btree, right): btree[2] = data 用这套函数进行递归调用，可以改出很复杂的二叉树，例如： t1 = BinTree(2, BinTree(4),BinTree(8)) 另外，也可以对这个东西进行修改： set_left(left(t1), BinTree(5)) 二叉树的简单应用：表达式树 二元表达式&amp;二叉树 基本运算对象作为叶结点 运算符作为分支结点 表达式一旦生成，就不会改变，所以采用“不变形式”的tuple进行计算会比较方便。 1234567891011def make_sum(a, b): return ('+', a,b)def make_prod(a, b): return("*", a, b)def make_diff(a, b)； return('-', a, b)def make_div(a, b): return('/', a, b) 这样可以用上面定义的内容构造一个简单的表达式： el = make_prod(3, make_sum(2, 5)) 另外，在处理表达式的时候，还需要注意区别基本表达式（一个数字或者变量）和复合表达式（一个包含运算符号的元组）。 123456# 判断是否是基本表达式def is_basic_exp(a): return not isinstance(a, tuple)# 判断是否是数值def is_number(x)； return(isinstance(x, int) or instance(x, float) or isinstance(x, complex)) 表达式的求值 首先根据数学，有下面表达式的求值规则： 数和变量的值就是他们自身； 表达式根据运算符的情况处理，可以定义专门的处理函数； 如果一个运算符的两个运算符的情况处理，可以定义专门的处理函数。 123456789101112131415def eval_exp(e): if is_basic_exp(e)； return e op, a, b = e[0],eval_exp(e[1], eval_exp[2]) if op == "+": return eval_sum(a, b) elif op == "-": return eval_diff(a, b) elif op == "*": return eval_prod(a, b) elif op == "/": return eval_div(a, b) else: raise ValueError("Unknown operator:", op) 接下来还可以给出对和式和除式求职的函数。 123456789101112131415161718def eval_sum(a, b): if is_number(a) and is_number(b): return a + b if is_number(a) and a == 0: return b if is_number(b) and b == 0: return a return make_sum(a, b)# 定义除法def eval_div(a, b): if is_number(b) and b == 0: raise ZeroDivisonError if is_number(a) and is_number(b): return a/b if is_number(b) and b == 1: return a if is_number(a) and a == 0: return 0 优先队列 这里再介绍另一种缓存结构：优先队列与栈和队列相似，可以将数据元素保存在其中。 优先队列基于线性表的实现 树形结构和堆 线性和树形结构 由于按序插入操作效率低（要沿着表顺序检索插入位置），只要按照优先级顺序线性排列，就无法避免线性复杂性问题。 堆及其性质 采用属性结构实现优先队列的一种有效技术称为 堆。从结构上看，堆是结点里存储数据的完全二叉树。并且有特殊的堆序：任何一个结点里存储的数据（按所考虑的序）先于或者等于其子结点（如果存在）里的数据。 根据堆的定义，有： 在一个堆中，从树根到任何一个叶结点的路径上，各结点里所存的数据按规定的优先关系（非严格）递减； 堆顶一定是堆中最优先的元素（所以获取成本很低） 树中不同路径上的元素，不关心他们之间的顺序关系； 【注】 由于二叉树和连续表的形式可以一一对应，所以在表达的时候，把二叉树写成线性表的形式也是可以的，二者可以通过下标一一对应。 优先队列的堆实现 插入元素和向上筛选 解决堆插入和删除的关键操作称为“筛选”，分为向上筛选和向下筛选。 向上筛选 用新加入的元素（设为e）与其父结点进行比较，如果e较小就交换两个元素的位置，从而元素e可以不断上移。由于比较和交换的次数不会超过二叉树中最长路径的长度，所以根据完全二叉树的性质，加入元素的操作可以在O(logn)O(\log n)O(logn)的时间内完成 弹出元素和向下筛选 弹出：堆顶元素 弹出堆顶后的元素不再是堆，但是它的两个子堆依然是堆，如果取出原堆的最后一个元素填补到堆顶，就可以把它做成一棵完全二叉树。除了堆顶元素不满足堆序，其他元素依然满足堆序。从这样的二叉树结构恢复堆结构的操作叫向下筛选。 假设堆顶元素e和两个子堆的堆顶A，B。具体操作可以通过类似于“递归”的思想实现： 将e和A,B做比较，最小者作为堆顶；e和其中的最小者交换顺序 接下来的操作就和之前的操作一样，规模更小。 如果某次比较中，e已经是最小元素，则堆已经成立 如果e已经到底层，则堆也成立。 向下筛选的操作也是O(logn)O(\log n)O(logn)的操作，其长度不会超过树的最大高度。 堆的应用：堆排序 基于堆的优先队列的实现以及堆排序 应用：离散事件模拟 被模拟系统可以抽象为一些离散事件的发生，所发生的事件可以引发新的事件。（马尔科夫链？？） 模拟系统的特点： 系统中不断发生一些事件 一个事件在某个时刻发生，那它的发生有可能导致其他事件在未来发生。 【具体实现】一个负责检查过境车辆的海关检查站，notebook 车辆按一定时间间隔到达，间隔有随机性，范围为[a,b]分钟 不同车辆的检查时间也不同，随机分布在[c,d]之间。 海关可以开k个通道 目的： 希望可以研究出不同的通道数量对车辆通行的影响，以及每辆车辆的平均等待时间和通过检查站的平均时间。 二叉树的类实现 上面几种方法是基于list或者tuple，对二叉树的一些应用。 接下的这种二叉树实现方法称为“链接实现”，用数据单元表示一个二叉树结点，通过子结点链接（指针）建立结点之间的联系。采用这种表示方法，只要知道了一棵二叉树的根节点，就掌握了整个二叉树。 二叉树结点类 二叉树是由一组结点构成的，所以先定义一个表示二叉树结点的类。 12345class BinTNode: def __init__(self, dat, left = None, right = None): self.data = dat self.left = left self.right = right 二叉树类 基于二叉树结点类定义的二叉树类： 哈夫曼树 哈夫曼树（Huffman tree)是一种重要的二叉树，在信息领域有重要的理论和实际价值。 哈夫曼树和哈夫曼算法 根到其外部结点的路径长度之和： E=∑i=1mliE = \sum_{i=1}^{m}l_i E=​i=1​∑​m​​l​i​​ 其中mmm是扩充二叉树中外部结点的个数，lil_il​i​​是从根到外部结点iii的路径长度。 【定义】 在权为wl，w2，…，wn的n个叶子所构成的所有二叉树中，带权路径长度最小(即代价最小)的二叉树称为最优二叉树或哈夫曼树。 带权扩充二叉树的外部路径及其长度 给扩充二叉树的每个外部结点标一下数值，称为该结点的 权 ，表示与该叶有关的某种性质，进而定义 带权扩充二叉树 的外部路径长度为： WPL=∑i=1mwiliWPL = \sum_{i=1}^{m}w_il_i WPL=​i=1​∑​m​​w​i​​l​i​​ wiw_iw​i​​是外部结点的权。 注意这里的wiw_iw​i​​是一个集合而不是一个序列，集合中的实数集可以按照任意方式选取。 构造哈夫曼树的算法 从任意的实数集合构造出与之对应的哈夫曼树，描述如下： 算法的输入为实数集W={w_0,w_1,...,w_{m-1} 在构造中维护一个包含k棵二叉树的集合F，开始时k=mk=mk=m且F={T_0,T_1,…，T_{m-1}，其中每个TiT_iT​i​​是一棵只包含权为wiw_iw​i​​的根节点的单点二叉树。 算法过程中重复执行下面两个步骤，直到集合F中剩下一棵树为止； 构造一棵新二叉树，其左右子树是从集合F中选取的两棵权最小的二叉树，其根结点的权值设置为这两棵子树的根节点的权值之和。 将所选的两棵二叉树从F中删除，把新构造的二叉树加入F。 【注意】 构造中，有时会产生多重选择的情况，就会产生不同结构的哈夫曼树，但是它的外部路径的长度一定相等。 哈夫曼算法的实现 算法一开始应当建立起一组单结点的二叉树，以权值作为优先码存入优先队列，要求先取出队列里的最小元素。然后重复以下步骤，直至队列中只有一个元素： 优先队列里弹出两个权最小的元素（两棵二叉树） 基于所取的二叉树构造一棵新的二叉树，其权值取两棵子树的权值之和，并将新构造的二叉树压入优先队列。 还有两个必须解决的小问题： 需要为二叉树定义一个序，权值小的二叉树在前； 需要检查优先队列中的元素（二叉树）个数，以便在只剩一棵时结束。 哈夫曼树的实现 ** 因为很久没看了，所以针对知识点有点遗忘，打算先把后续的看完再回头补，待更 **]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好难四儿啊]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%A5%BD%E9%9A%BE%E5%9B%9B%E5%84%BF%E5%95%8A%2F</url>
    <content type="text"><![CDATA[今儿在图书馆学习，学到了有关计算的前缀、中缀和后缀的内容。突然想到之前读过的一篇短篇科幻《好难四儿啊，那些鹁鸦鸲子》 这篇文章说的是思维定式。今天看到前缀后缀很明显会比中缀简单很多（因为不需要加上括号之类的辅助就可以把一个表达式写得清清楚楚），然而我读起来实在是吃力。可能这就是思维定式吧。 这是我鲜有意识到思维局限的情况，人往往都是愚蠢而不自知的。]]></content>
      <categories>
        <category>杂想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构Pyhton（四）-栈和队列.md]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-md%2F</url>
    <content type="text"><![CDATA[在常用的数据结构中，有一批结构被称为“容器”。一个容器结构里总包含一组其他类型的数据对象，称其为元素。 除了线性表以外，还有两种最常用的容器，称为栈（stack)和队列(queue)，他们都是使用最广泛的数据结构。 本章重点 栈和队列的定义 栈和递归 栈和队列的应用：迷宫求解问题 概述 栈：保证元素后进先出（Last In First Out,LIFO)，简称LIFO结构。 队列：保证元素先进先出（First In First Out) 栈（stack) 栈结构的顺序表实现 12345678910111213141516171819class SStack(): def __init__(self): # 用list对象_elem存储栈中元素 self._elems = [] # 所有栈操作都映射到list中 def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow("in SStack.top()") return self.elem[-1] # 后进先出，得到最后一个元素 def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow("in SStack.pop()") return self._elems.pop() # 以列表形式弹出 栈的链接表实现 以下是基于LNode链接表实现的。有关于LNode的定义见这篇文章 123456789101112131415161718192021class LStack(): # 基于链接表技术实现的栈类，用LNode作为结点 def __init__(self): self._top = None def is_empty(self): return self._top is None def top(self): if self._top is None: raise StackUnderflow("in LStack.top()") return self._top.elem def push(self, elem): self._top = LNode(elem, self._top) def pop(self): if self._top is None: raise StackUnderflow("in LStack pop()") p = self._top self._top = p.next return p.elem 栈的应用 算法或者程序里的辅助存储结构 后进先出的性质，保证特定的存取顺序。 颠倒一组的顺序 12345678#假设list1里存储这要颠倒的列表list1 = [1, 2, 3, 4, 5]st1 = SStack()for x in list1: st1.push(x)list2 = []while not st1.is_empty(): list2.append(st1.pop()) 括号匹配问题 逻辑： 检查文本，找出括号 找到的开括号，压进栈中 找到的闭括号和最近找到的开括号进行匹配； 成功则继续，不匹配则以失败结束。 代码实现： 1234567891011121314151617181920212223242526272829303132def check_parens(text): """ 括号匹配检查函数，text是被检查的正文串 """ parens = "()[]&#123;&#125;" open_parens = "([&#123;" opposite = &#123;")":"(", "]": "[", "&#125;": "&#123;"&#125; # 表示配对关系的字典 def parentheses(text): """括号生成器，每次调用返回text里的下一括号及其位置""" i, text_len = 0, len(text) while True: while i &lt; text_len and text[i] not in parens: i += 1 if i &gt;= text_len: return yield text[i], i print(text[i]) i += 1 st = SStack() # 保存括号的栈 for pr, i in parentheses(text): # 对text里各括号和位置进行迭代 if pr in open_parens: st.push(pr) # 如果是开括号，就押进栈 elif st.pop() != opposite[pr]: # 如果不匹配就失败 print("Unmatching is found at", i , "for", pr) return False else: pass # 因为成功了，就啥都不做 print("All parenthese are correctly matched") return True 表达式的表示、计算和变换 后缀表达式的计算： 生成一个判断对象类别的函数（是运算度还是运算对象？）nextItem() 如果是运算对象，存起来以备后续is_operated() 如果是运算符（假设都是二元运算符），则取得前面的对象或者已经运算得到的结果，进行计算并保存结果。 这就涉及到存储结构的问题。因为每次结果都不能直接使用，而是应当缓存起来，以备后续。 需要记录的是已经掌握的数据 每次处理运算符都应该用最后记录的几个结果（二元运算符就是2）。 给出算法框架如下： 123456789while 还有输入: x = nextItem() if is_operand(x): # 是运算对象，转换为浮点数并入栈 st.push(float(x)) else: a = st.pop() # 第二个运算对象 b = st.pop() # 第一个运算对象 … … 现在细化一下。 首先，应当定义一个函数，把输入的字符行分割成项。 12def suffix_exp_evaluator(line): return suf_exp_evaluator(line.split()) 其余更详细的还是戳这里 栈与递归 在一个数据结构里，某个或者某几个部分具有与整体相同的结构，就称之为这是一种递归结构。 例如，由结点通过链接构成的单链表，就是递归的实例。这种表或者为空，或者在其非空时，去掉第一个结点后剩下的结点链仍然具有相同的结构。 递归结构需要一个终结点，这个终结点应当是非递归的，由基本结构构成的部分。窦泽，就会出现无线递归，不能成为良好的定义。 结点链的空链接（None)就是递归的终点 阶乘函数的递归计算 12345def fact(n): if n == 0 : return 1 else: return n * fact(n-1) 这个递归计算是一个“后进先出”的实例。如果要计算fact(3)，则先把参数3压入栈；随后执行调用fact(2)，把参数2压入栈。知道执行fact(0)得到结果1后，先和参数2相乘，再和参数3相乘，从而是一个典型的“后进先出”实例。 递归/函数调用 如果要支持递归定义函数的实现，就需要一个栈来保存递归函数执行时每一层调用的局部信息，留着函数调用返回后继续使用。 函数调用也是一样的，都是“后调用先返回”思想。 递归与非递归的对应 摸清楚里面的结构之后，可以自己管理栈来模拟函数的调用过程，比如下面的实现。 123456789def norec_fact(n): # 自己管理栈来模拟函数的调用过程 res = 1 st = SStack() while n &gt; 0: st.push(n) n -= 1 while not st.is_empty(): res *= st.pop() return res 递归函数与非递归函数 与此对应的，任何一个包含循环的程序都可以翻译为一个不包含循环的递归函数。 不过作者也说了，因为现在大部分调用函数的效率损失是可以接受的，所以大部分情况下可以不考虑，只有一些特殊的情况需要做这种工作。 栈的应用：简单背包问题 背包里可以放入重量为weightweightweight的物品，现在有nnn件物品的集合SSS，其中物品的重量分别为w0,w1,...,wn1w_0, w_1,...,w_{n_1}w​0​​,w​1​​,...,w​n​1​​​​，问题是喜爱你在能否从中选出若干件物品，使其重量之和刚好等于weightweightweight，存在则有解，否则无解。 现在考虑问题的求解：用记法knap(weight, n)表示n件物品相对于总重量weightweightweight的背包问题。考虑一件物品的选/不选，把问题划分为两种情况： 不选最后一件物品，那么knap(weight,n−1)knap(weight, n-1)knap(weight,n−1)的解就是knap(weight,n)knap(weight, n)knap(weight,n)的解，找到前者的解就是找到后者的解。 若选择最后意见物品，则如果knap(weight−wn−1,n−1)knap(weight-w_{n-1}, n-1)knap(weight−w​n−1​​,n−1)有解，其解再加上最后一件物品就是knap(weight,n)knap(weight, n)knap(weight,n)的解，即前者有解，后者就有解。 这说明，我们可以把背包问题归结为两个子问题。第一类情况下，总重量不变但是物品数量-1；第二种情况，总重量减少，物品数量也减少。只要任何一个子问题有解，这个问题就应当有解。 最后，我们可以把这个问题归结为最简单的三种情况： 总重量为0，这说明有解 总重量小于0，因为在递归的过程中，重量总是递减的，有可能出现这种情况，这说明目前已有的安排不能满足条件 总重量大于0但是没有物品可以用了，说明这个问题无解。 所以我们按照上述分析可以实现以下的代码： 1234567891011def knap_rec(weight, wlist, n): if weight == 0: return True if weight &lt; 0 or (weight &gt; 0 and n &lt; 1): return False if knap_rec(weight - wlist[n-1], wlist, n-1): # 子问题1 print("Item" + str(n) + ":", wlist[n-1]) return True if knap_rec(weight, wlist, n-1): # 子问题2 return True else: return False 队列 队列(queue)，又被称为队，也是一种容器，可以存入元素、访问元素或者删除元素。 队列抽象数据类型 123456ADT Queue: Queue (self) # 创建空队列 is_empty(self) # 判断队列是否为空，为空时，返回True；否则返回false enqueue(self, elem) # 将元素elem入队 dequeue(self) 删除队列里最早进入的元素并返回其值，称为出队 peek(self) # 查看队列里最早进入的元素，不删除 链接表技术的队列实现：采用带表尾指针的单链表。它支持O（1）时间的表尾插入以及表首的访问和删除。 队列的顺序表实现：循环顺序表 队列使用时，顺序表的开始位置不改变； 队头变量q.head记录当前队列里的第一个元素的位置；队尾变量q.rear记录当前队列里最后元素之后的第一个空位。 队列元素保持在顺序表的一段连续单元中，即[q.head:q.rear] 出队和入队操作需要更新变量q.head和q.rear，正确更新操作如下： 12q.head = (q.head + 1) % q.lenq.rear = (q.rear + 1) % 1.len 注意这里的值是用来更新变量q.head和q.rear的指针位置的。 另外，队列状态也需要判断。循环顺序表性质决定了它可以存储的数据量是固定的。当表满的时候会出现q.head = q.rear，这和表空的形式是是一样的，从而不能区分。我们这里需要另外定义一个表满的情况。即(q.rear + 1)%q.len = q.head，而采用这种方法会导致表中出现一个多余的空位。 队列的list实现 look here 迷宫问题的求解和状态空间搜索 我们这里考虑二维平面的迷宫问题。 表示方式 采用0/1形式来表示迷宫。0表示通路，1表示封闭点 对于其中的某一个格子，如果它的方位是(i,j)，则他四周的方位则表示为这个二元组分别加上后面这些：dirs = [(0,1),(1,0),(0,-1),(-1,0)]。 关于问题的定义 为防止在局部上绕圈，找过的位置改为2，这样判断时只要判断其位置是否为0即可。 如果一个位置有多个方向可以选择，按照上述的形式找出位置后，只需要执行一个简单的循环，遍历可能的路径即可。 具体的实现过程look here 基于栈和队列的搜索过程 栈和队列的搜索过程的区别在哪里呢？~ 以迷宫为例，栈是深度搜索（会把一条路径都搜索完，直到思路为止）；而队列是宽度搜索（会搜索每一条路径的相同长度）。 深度和宽度优先搜索的性质： 能否保证找到解？ 深度：如果有无求多的子空间，则有可能卡在某一子空间上，找不到解； 宽度：只要存在有穷长路径，就能找到解，而且找到的一定是最短路径（最短解） 找到解如何得到相应路径？ 栈：保存在栈中的就是相应路径 队列：需要单独做一个对应的字典来保存前述位置，但是这样对于状态空间很大的解来说需要的存储空间太大了，不是很友好。 搜索所有可能的解和最优解？ 栈：深度搜索必须要穷举所有的解后才能得到最优解，状态空间很大时不能成立 队列： 不需要穷举，第一个获得的解就一定是最优解 搜索的时间开销和空间开销？ 对于栈和队列而言，探查位置的开销都是O（1），所以主要开销在空间开销上。 栈的空间开销：搜索过的最长路径。 队列：主要是由分支最多的那一层决定的；此外为了得到路径还需要额外的存储。开销也可能很大。 总结：一个问题可以用空间搜索的方式解决的话，栈和队列还是各有优势，主要还是考虑他们的空间开销和需要找到几个最优解来确定最终的解决方案。 几点补充 几种与栈或者队列相关的结构 双端队列：允许两端插入和删除元素；因此功能覆盖上面的所有结构。 python的deque类 ……]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（三）-字符串]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本章重点 KMP算法 python的正则表达式 re的匹配对象（match） 字符集、字符串和字符串操作 由于字符串处理的需要，要求字符集上有一种确定的序关系，称为字符序。故而，对于字符集中任意两个字符，&lt;, =, &gt;三种关系之一成立。 字符串可以被看为是一种特殊的线性表，但是由于字符串有很多自身特殊的处理方式，所以经常会把字符串作为一个整体使用和处理，考虑许多以整个串作为你对象的操作。 字符串的相关概念。 字符串的长度 字符在字符串中的位置 字符串相等(长度和字符) 字典序：字典序是字符串上的一种序关系。从左向右查看的两个串中下标相同的各对字符，遇到的第一对不同字符的字符串决定了这两个字符串的顺序。abc &lt; abd, 且abc &lt; abcd。 字符串拼接 子串关系 前缀和后缀：若存在s1=s2+s′s_1 = s_2 + s&#x27;s​1​​=s​2​​+s​′​​，则称s1s_1s​1​​为s2s_2s​2​​的一个前缀。后缀同理。s的开头/结尾的任何一个子串都是它的前缀/后缀。空串和s既是s的前缀，也是s的后缀。 字符串的实现 在实现字符串时，需要考虑两个问题 字符串的存储：全部放在一起存储太占空间，而一个一个存储需要很多链接域，额外开销大，故而实际中，可以折中，将字符串分段保存在一组存储块里，并链接起这些存储块。 串结束的表示：①用数据域记录编码长度。②用特殊编码表示结束。 字符串匹配（子串查找） wiki网页：字符串搜索 朴素的串匹配算法 123456789101112def naive_matching(t, p): #查找t中是否有子串p m, n = len(p), len(t) i, j = 0, 0 while i &lt; m and j &lt; n: # 当i == m时找到了匹配 if p[i] == t[j]: # 该字符匹配，进行下一位的匹配 i += 1 j += 1 else: i, j = 0, j - i + 1 # 该字符不匹配，故而从字符串的下一位开始继续匹配。（ if i == m: # 找到了匹配的子串，返回其起始下标 return j - i return -1 # 无匹配，就返回特殊值 其中，j-i+1就是考虑的从字符串上次开始的下一位开始匹配。 该算法的最坏情况是每次都在最后一位匹配失败，需要匹配m×(n−m+1)m\times (n-m+1)m×(n−m+1)次，所以算法复杂度为m*n。 无回溯串匹配算法（KMP算法） KPM算法的分析 基本思想是对于已经匹配过的元素无回溯。 如果模式串pip_ip​i​​和某个tjt_jt​j​​匹配失败了，下一步是找一个ki(1&lt;ki&lt;m)k_i(1 &lt; k_i &lt; m)k​i​​(1&lt;k​i​​&lt;m)，将模式串后移若干位，匹配pkip_{k_i}p​k​i​​​​和tjt_jt​j​​。 问题的关键就是如何确定kik_ik​i​​。实际上，对于模式串中的每一个元素i,都应该有一个确定的kik_ik​i​​和它一一对应。通过对模式串本身的分析，得到相应的kik_ik​i​​并存储起在pnext[i]表中。 有一种特殊情况是，某pip_ip​i​​匹配失败后，发现之前做过的匹配都没有价值，则下一步就需要从头开始，用p0p_0p​0​​和tj−i+1t_{j-i+1}t​j−i+1​​比较1。针对这种情况，取pnext[i] = -1 KPM算法的实现 假设已经做出了pnext表，以下考虑KMP算法的实现： 注意这里有两个指针，指针i指向匹配串p,指针j指向被匹配串t。 1234567while j &lt; n and i &lt; m: # i == m 说明找到了匹配 if i == -1: # 遇到-1的话匹配下一对字符，j和i同时往后挪。 j, i = j + 1, i + 1 elif t[j] == p[i] # 如果相等，就再比较下一对字符，j和i也同时往后挪。 j, i = j+1, i+1 else: i = pnext[i] # 取第i个字符的 其中，if语句中的两个分支可以合并，有： 12345678910111213# 核心循环步骤def matching_KMP(t, p, pnext): '''KMP串匹配，主函数 ''' j ,i = 0, 0 n, m = len(t), len(p) while j &lt; n and i &lt; m: if i == -1 or p[i] == t[j]: j, i = j + 1, i + 1 else: i = pnext[i] if i == m: return j-i return -1 构造pnext表：分析 如果在位置i匹配失败，那么位置i对应的pnext[i]这个位置应该满足两个条件： 选择的该位置的前缀子串，应该和i前相同长度的子串一致 如果满足上述条件的位置不止一个，则应该移动最短距离，以防止有匹配的遗漏。 实际上，经过一波分析，问题被转化成为：寻找匹配串p中，前i个位置的最长的相同的前缀和后缀。k就是它们的长度，只有这样才能保证不会跳过可能的匹配。 以下是设计出的巧妙算法： 若已经对pnext[i-1]计算出结果为k-1,再比较p[i]和p[k]，有两种情况： 如果pi=pkp_i = p_kp​i​​=p​k​​,说明对于i的最长相等前后缀的长度，比对i-1的最长相等前后缀的长度多1，由此，应该把pnext[i]设置为k，然后考虑下一字符。 否则，应该把p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀拿来做检查。（注意这里只是检查而没有设置，因为p0...pk−1p_0...p_{k-1}p​0​​...p​k−1​​的最长相等前缀也是p0...pi−1p_0...p_{i-1}p​0​​...p​i−1​​的某一个相等前缀（不一定是最长的），所以可以拿来做检查。 如果是已知pnext[0]=-1和直至pnext[i-1]的已有值求pnext[i]的算法： 假设pnext[i-1]=k-1,如果pi=pkp_i=p_kp​i​​=p​k​​，那么p0...pip_0...p_{i}p​0​​...p​i​​的最长相等前后缀的长度就为k，设置pnext[i]=k，将i+1后继续循环； 如果pi≠pkp_i \ne p_kp​i​​≠p​k​​，则设置k = pnext[k]（转去考虑前一个更短的，又能保证匹配的前缀）； 若k=−1k=-1k=−1（等于-1是从第二步pnext来的），则p0...p1p_0...p_1p​0​​...p​1​​的最长相等前缀的长度就是0，设置pnext[i]=02,然后将i+1后继续递推。 这里k就是最长相等前缀个数，它也是一个指针 KMP算法的时间复杂度是O（m+n）. 字符串匹配问题 串匹配、搜索的不同需要 人们需要查找的是具有某种形式的字符串。&lt;\font color = gray&gt;（比如re包里的正则匹配？）&lt;\font&gt; 通配符：比如*，与任意一串字符串匹配；?，与任何一个实际字符匹配。 正则表达式（Regular Expression）。 Python的正则表达式语言 基本情况 原始字符串 在普通字符串前加上“r”或者“R”，内部的“\”不进行转义。 元字符（特殊字符） 共14个，这些元字符起着特殊的作用： $ . ^ * + ? \ | { } [ ] ( )$ 主要操作 字符操作 生成正则表达式对象：re.compile(&lt;正则表达式&gt;) r1 = re.compile(&quot;abc:) 这样做的好处是可以避免重复生成正则表达式 检索：re.search(&lt;正则表达式&gt;, &lt;字符串&gt;) 若找到，则返回一个match类型的对象。否则，返回None。match类型的对象还可以被作真值直接进行逻辑判断。 匹配：re.match(&lt;正则表达式pattern&gt;, &lt;字符串string&gt;) 检查string是否存在和pattern匹配的前缀，如果找到则返回一个match类型的对象；否则返回None。match对象里记录的是成功匹配的相关信息。 例如： 12re.search(r1,'aaabcbcbabcb') # 将匹配成功re.match(r1, 'aaabcbcbabcb') # 将匹配失败 分割：re.split(pattern, string, maxsplit, flag = 0) 12345re.split(' ', "aaa bbb abc are not the same")&gt;&gt;&gt; ['aaa', 'bbb', 'abc', 'are', 'not', 'the', 'same']re.split[" ", "a b c d"]&gt;&gt;&gt; ['a', 'b', '', 'c', '', '', 'd'] #得到几个空串 找出所有匹配串：re.findall(pattern, string, flags = 0) 字符组 字符组形式：[……]，其中的元素顺序不重要。它会和字符组中的任何一个字符串匹配，称为字符组描述。例如，[abc]可以和a或b或c进行匹配。 区间形式：【0-9][a-z],它还可以和字符列表混写，比如[34ad-fs-z] 特殊形式[……]它表示的是对于之后列出的字符组求补。即这种字符组表达式与所有没有列在括号里的字符串匹配。比如，[0-9]匹配非十进制数字的所有字符。 注意如果需要在字符组里包含&quot;[]“或者“^”，则都应该在前面加上&quot;\”进行转义。 圆点字符(.)，这是一个能匹配任何字符的通配符。 例如，模式串a…b匹配所有以a开头b结尾的四字字符。 例如，p\w\w\w可以和p开头随后为任意三个字母数字的串进行匹配。 重复描述符（*） 例如，模式a*要求匹配模式a能匹配字符串的0次或者任意多次重复。re.split('[ ,]*, s)可以把按照任意多个空格或者,来分割s。 在考量重复匹配时，如果有多个子串满足条件，有两种匹配方式： 贪婪匹配：匹配最长子串 非贪婪匹配（吝啬匹配）：模式有可能匹配的最短子串。 此外，“+”表示至少一次匹配。 可选描述符 “a?&quot;表示和a的0或1次重复匹配。 重复次数描述符 a{n}表示和a匹配的串的n次重复匹配。 重复次数范围描述符 a{m, n},a{,n}(等价于a{m,n})，a{m,}等价于a{m, infinity} 注意*、+、？、{m,n}都采用贪婪匹配规则。 非贪婪匹配描述符： *？，+？，？？，{m,n}?采用的都是非贪婪匹配策略。 选择 选择描述符：|，它的结合力是最弱的，比顺序组合的结合力还要弱。 首尾描述符 行首描述符：以“^&quot;符号开头的模式，只能与一行的前缀子串匹配。 12re.search('^for', "books for children") # 结果为Nonere.search("^for", "books \nofor children") # 匹配成功 行尾描述符：以&quot;$&quot;符号结尾的模式，与一样的后缀子串匹配。 12re.search("$fish", "cats like to eat fishes") # 结果为Nonere.search("$like", "cats like\neat fishes") # 匹配成功 匹配对象（match对象） 逻辑：match对象总表示逻辑为真，所以可以被用作逻辑判断 取得子串：mat.group() 在目标串里的匹配位置：mat.start() 取得mat代表的成功匹配在目标串里的实际匹配位置。 目标串中被匹配子串的结束位置：mat.end() 目标串里被匹配的区间：mat.span() 得到匹配的开始和结束位置形成的二元组。也就是说 1mat.span() == mat.start(), mat.end() 其他：mat.re和mat.string（这两个表达式是数据域访问，不是函数），分别取得这个match对象所做匹配的正则表达式对象和目标串。 模式里的组（group） 圆括号表示模式段中的一个组。使用mat.group(n)来调取与其中第n组匹配的字符串。mat.group(0)表示与整个模式匹配的字符串。 另外，match.groups将得到一个序对。 组的另外一个用途是，在匹配中应用前面的成功匹配。比如r&quot;(.{.{2}) \1可以匹配&quot;ok ok&quot;（两个字符，加一个空格，然后匹配相同的内容），不能匹配“oh no&quot; 其他匹配操作 re.fullmatch(pattern, string, flags = 0)，若整个string和pattern配对成功，返回match对象 re.finditer(pattern, string, flags = 0)，和findall类似，但是它会返回一个迭代器，顺序取得各非重叠匹配得到的match对象。 re.sub(pattern, repl, string, conut = 0, flags = 0)，生成替换结果的串。repl可以直接是一个字符串，也可以是一个以match对象为参数的函数。用其调用match对象的返回值来替换被匹配的子串。 正则表达式对象 re.compile(pattern)生成一个正则表达式对象。除了用来搜索外，它本身还支持另一组方法，功能也更强。以下用regex来表示一个正则表达式对象，它有这样一些方法： 检索：regex.search(string[,pos[,endpos]])，可以指定检索的开始和结束位置。 匹配：regex.match(string[,pos[,endpos]])，也可以指定匹配区间。 完全匹配：regex.fullmatch(string[,pos[,endpos]])，检查string中由指定范围构成的子串是否和regex匹配。 正则表达式的使用 如果目标串中存在一些（或者很多）与正则表达式匹配的子串，需要逐个处理，在这种情况下采用迭代器的方式最方便。编程模式是： 1234rel = re.compile(pattern)for mat in rel.finditer(text): ...mat.group()... # 取得被匹配的子串，做所需操作。 ... text[mat.start()]...text[mat.end()]... 不过这种写法有点繁琐，拿到这种字符串，先考虑能不能用re.sub进行处理，如果实在不行再用迭代器方案。 单词边界 \b描述单词边界。但是，python字符串中\b表示退格符，这两个重复了。有连个方法可以解决这个问题 模式串中的\双写。 模式串采用原始字符串的形式（加上r) python程序里的整数匹配可以写为：r'\b(0+|[1-9]\d*)\b' 若是希望匹配带有正负号的一般整数，可以写为：r'\b[+-]?(0+|[1-9]\d*)\b 补充 为了方便，re还提供了如下以转义串形式定义的常用字符组，包括： \d: [0-9] \D: [^0-9] \s: [ \t\v\n\f\r] 即与所有空白字符进行匹配 \S: [^ \t\v\n\f\r] 与所有非空白字符进行匹配 \w：[0-9a-zA-Z] \W：[^0-9a-zA-Z] 1.这里我觉得书中描述不清，应当是直接从上一次匹配的下一个进行匹配，所以应当是$t_{j-i+1}$而不是$t_{j+1}$开始匹配 ↩2.这个地方有一点奇怪，如果设置为0的话，-1是哪里来的…… ↩]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《道林·格雷的画像》摘抄]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近来疯狂迷恋王尔德。 书没有道德和不道德之分，只有写得好的和写得差的，仅此而已。 “哦，我也说不清楚。当我心有挚爱时，我绝不向任何人说出他们是谁，说出来就好比一点点出卖他们。我愈来愈喜爱隐秘了，这样似乎能使我们体会到现代生活的秘密和美妙。” 顺其自然才是一种姿态，而且是据我所知最令人恼火的姿态。 至于信不信的问题，只要不可信的，我都相信。 或者就敌意而言，何为敌意？你对人人都喜欢，也就是说，你对人人都漠然。 1 我交朋友，都是因为他们长得好看（哈哈哈哈哈）；我结识人，都是因为他们有好的性格；我选敌人，都是因为他们有智慧。 但无疑天赋比美貌更持久，这也是我们都拼命接受过多教育的原因。在疯狂的生存竞争中，我们都希望拥有某种持久不灭的东西，所以我们用垃圾和事实填满我们的思想，愚蠢地希望保持自己的地位。无所不知的人——这就是现代人的理想，而无所不知的人的思想让人感到恐怖。它就像一个小古董店，里面只有怪物和灰尘，一切都价过其实。 ——“世上没有‘好道德’这种东西，格雷先生。所有影响都是不道德的，从科学的角度看，都不道德。” ——“为什么？” ——“因为影响一个人，就是把自己的灵魂给他。他就不会依从自己的天性思考，或让自己天性的激情燃烧。他的美德不真的属于他。他的罪孽，要是有罪孽存在的话，也都是借来的。他成了别人音乐的一个回声，一个并非为他而写的剧本中的演员。生活的目的就是自我进步，要完全释放自己的天性——这是我们每个人来到人世的目的。现如今，人们竟怕起自己来了。他们忘记了自己的最高职责，即对自己应付的责任。 我相信，如果一个人能活得充分、彻底、表现出每一种感情，表达出每一种思想，实现每一种梦想——我相信，世界会获得如此新鲜的喜悦的冲动，会因此使我们忘掉中世纪时代的所有弊病，重回希腊的理想——可能是某种比希腊理想更美好，更富饶的东西。 只有感官才能拯救灵魂，就像只有灵魂才能拯救感官一样。 美是世上的一大客观存在，就像阳光、春光，或者我们称之为月亮的，银色贝壳般在水中的倒影，这是毋庸置疑的。 人有时会说美只是一种肤浅的东西。或许如此，但至少不会像思想一样肤浅。对我而言，美是奇迹中的奇迹。只有浅薄之人才不以貌取人。世界真正的神秘存在于可见之物，而非不可见之物。 啊！当你拥有青春时，你就要认识到它。不要虚掷你的黄金岁月，去听冗长乏味的说教，试图弥补无妄的失败，或把你的生命献给无知、庸常和低俗。 活着！活出你宝贵的内在生命。什么都不要错过，始终去寻找新的感受。无所畏惧…… 现在的人啊，什么东西的价格都知道，但它们的价值，都不知道。 男人结婚是因为厌倦，女人结婚是因为好奇，结果是双方都感到失望。 我不是在笑，道林，至少不是在笑你，但你不该说这是你一生中最浪漫的事。你应当说是你一生中的第一次浪漫。你会一直有人爱，你也会一直爱上爱，多情是无所事事者的特权，一生只爱一次的人才是真正的浅薄之人。他们自称忠实、忠诚，我则称之为习惯懒惰，或是缺乏想象。忠诚之于感情生活，就像惯性之于理智生活——都只是承认失败。忠诚！将来我一定要研究研究这个东西。其中包含着对财产的贪欲。如果不是因为害怕被别人捡走，我们肯定要扔掉很多东西。2 拿别人的悲苦做谈资，总归是及其卑微的。 人都爱放弃自己随需要的东西，这就是我所谓的慷慨的深意。 好的艺术家，都只存在于他们的作品之中，他们本人都是极其无聊乏味的。伟大的诗人，真正伟大的诗人，都是世间万物中最没有诗情画意的家伙。但蹩脚诗人，却绝对魅力四射。诗写得越拙劣的诗人，看上去却越动人。 但经验中没有驱动力。它与良心一样，都不是积极的动因。实际上它所能昭示的一切，无非是我们的未来与我们的过去一模一样，我们曾经带着厌恨犯下的罪孽，我们会带着愉悦一再犯下去。 现如今，任何事我都不说赞成还是不赞成。这种带着生活的态度是荒谬的。我们被送到人世间，不是为了宣扬我们的到的偏见的。 我们之所以都喜欢把别人往好处想，是因为我们都为自己感到害怕。乐观主义的基础就是纯粹的恐惧，我们称赞邻居拥有那些美德，就以为我们自己慷慨，实际上只是因为那些美德可能对我们有利。我们赞扬银行家，只为可以透支；我们找出拦路强盗的优点，只是希望他会饶过我们的口袋。我说的话都当真。我最鄙视乐观主义。至于说生活被毁，没有什么生活会被毁，只有生长被遏制才是真的毁了。如果你想破坏一个人的本性，你只需改造它。 “‘善’，就是要与自身和谐。”他用苍白尖细的手指碰了碰手中杯子的细柄，说，“不和谐，就是被迫与他人维持和谐。人自身的生活才是重要的，至于周围人的生活，假如有人想做道学先生或清教徒，他尽可抒发自己的道德观念，但不管别人的事。除此之外，个人主义其实抱有更崇高的目标。现代道德就体现在接受自己时代的标准。而我认为，对任何一个有教养的人而言，接受自己时代的标准就是一种最严重的不道德。” 陈年旧事的唯一魅力，在于它已成旧事。 我们生活在一个读书太多反而愚蠢的年代，一个思考太多反而不美的时代。 表达赋予事物真实存在。 “做过就做过了，过去的已经过去了。”“你称昨天是过去？”“这与时间的实际长短有什么关系？只有浅薄的人才需要数年来摆脱一桩感情。” 人天生害怕比自身强大的激情和感觉，他们意识到自己与低级生物有同样的欲望和感受。 当然，这种新享乐主义是服务于理智的，不接受任何形式的，以牺牲情感体验为代价的理论或体系。事实上，它的目的就是体验本身，而非体验的结果，不管这种结果是苦是甜。禁欲主义使感觉丧失，庸俗的纵情挥霍使感情迟钝，这与新享乐主义无关。它要教会人珍视生活的一个个瞬间，而生活本身就如同一个瞬间。 山风呜咽叹息着，盘旋在寂静的房子周围，似乎担心惊醒沉睡者，却又必须把睡神从紫色的山洞中唤醒。层层叠叠昏暗的薄纱揭开了，万物渐渐恢复了形状和颜色，我们看着黎明以它古老的方式重塑世界。暗淡的镜子又开始它映射事物的一天，数支熄灭的细蜡烛依旧立在原地，旁边摆着一本裁了一半的书、在舞会上戴的用金属丝扎着的花儿，或者一封不敢读或读了太多遍的信。在我们看来，似乎什么都没变。熟识的现实生活从虚幻的夜影里回来了，我们不得不从原来中断的地方重新开始生活，一种可怕的感觉悄然袭来，我们必须在一成不变、让人厌倦的陈规里葆有继续的力量。 与生活本身相比，他似乎觉得没有什么理论是举足轻重的。 社会——至少文明社会——从不会轻易相信任何对有钱又有魅力的人的诋毁。 人是一种具有多重生活、多层感觉、多种形式的复杂生物，人的精神秉承了思想和激情的奇怪遗产，人的肉体沾染上了祖先的可怕疾病。 人既有文学上的祖先，也有血缘上的祖先，可能很多人在类别和性情方面与文学上的祖先更接近，也更能明显地意识到。有时，道林似乎觉得，整个人类历史都只不过是自己生活的记录，不是它的实际生活，而是他想象中创造的生活，在他的脑海和激情里。道林觉得仿佛认识那些奇怪而可怕的历史人物，他们在世界舞台中登场，又离开，把罪孽变得如此神奇，把邪恶变得如此微妙。他仿佛觉得，他们的生活通过某种神秘的方式，变成了他的生活。 我们每个人身上都既有天堂又有地域。 它曾一度厌恶丑陋，因为丑陋让事物显得真实，而现在恰恰因为这个原因，他觉得丑陋可爱。丑陋是唯一的真实，粗鲁的争吵、可恶的贼窝、乱糟糟的生活中粗野的暴力、窃贼和流浪汉的肮脏……这些给人留下强烈真实的印象，比一切艺术的优雅表象和音乐的梦幻影子生动得多。 每个人都有自己的生活之道，也都会为此付出代价。唯一的遗憾是人不得不因为一次过错不停地付出代价。实际上，是一而再、再而三地偿还。命运与人做交易，从不结清账户。 我不怕死，我怕的是死亡的临近。可怕的死亡之翼似乎就盘桓在我周围沉闷厚重的空气中。 现如今，除了死亡，人可幸免于一切。 灵魂一种可怕的现实。可以买可以卖，可以交换，可以予以毒害，或完善。我们每个人内心都有一颗灵魂。 只要能恢复青春，我愿意做任何事，除了锻炼、早起和道貌岸然。 老年人的悲剧不在于老了，而在于还想年轻。 青春是什么？至多只是一段青葱、幼稚的时光，充满了浅陋的情绪和病态的思绪。为什么他要做青春的奴仆？青春已经把他毁了。 1.把这句话发给导师之后，她说“对人人都漠然”简直很你了。 ↩2.这简直是我看到现在对于占有欲最通透的解释！ ↩]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>王尔德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（二）-线性表]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhton%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本章重点 线性表的定义 顺序表和链接表 线性表的概念和表抽象数据结构类型 表的概念和性质 E中一组有穷个元素排成的序列。表中包含的元素的个数成为表的长度。元素之间的关系成为“下一个关系”，这是一种顺序关系，也称为线性关系，是一种线性结构。 线性表的操作 一个线性表可以提供的操作有： 创建线性表的操作； 获取表中信息的解析操作（判断是否为空） 动态改变表的内容； 表的组合操作（merge，subset……） 对表元素的遍历问题（给定对单个元素的操作，也存在可以对表进行的操作） 最后的这两类可以实现变动操作（直接在原表基础上修改）或者非变动操作（在原表基础上产生新表）。 线性表的实现 基本考虑： 考虑计算机内容的特点，还有保存元素和元素顺序信息的需要。 各种重要操作的消耗。比如is_empty这种，消耗越小越好。 两种实现模型 顺序表：表中元素顺序地存放在一大块连续的存储区里； 链接表：通过连接构造起来的一系列存储块里。 基本实现方式 表里保存的元素类型相同。 在顺序表中，可以通过Loc(ei)=Loc(e0)+c * i来计算出ei的位置。时间复杂度为O（1）。 元素类型（长度）不同 这个时候可以考虑将实际元素另外存储，而在顺序表里各单位位置保存相应位置的引用信息（链接）。 顺序表 基本操作的实现以及时间复杂度 创建和访问操作 简单判断（是否为空，大小）：O（1） 访问指定下标为i的元素：O（1） 遍历操作：给定一个i，然后每次+1（向下）或者-1（向上），时间复杂度为O（n） 查找给定元素d（第一次出现）的位置：检索/查找。 不改变结构的操作，有两种：直接访问，时间复杂度为O（1）；或者基于一个整型变量循环得到结果的，时间复杂度为O（n） 变动操作：加入元素 在尾端加入数据：O（1） 在第i个位置加入元素：有两种情况 不需要保持原来的相对位置：把i的元素移动到位置num。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 变动操作：删除元素 尾端删除：O（1） 在第i个位置删除元素：也有两种情况 不需要保持原来的相对位置：把num-1的元素移动到位置i。时间复杂度：O（1）； 要保证相对位置：和要移动的元素个数成正比，平均和最坏的情况都为O（n）。 基于条件的删除：因为需要对元素进行遍历，故而时间复杂度也为O（n）。 顺序表的结构 顺序表可以用两种储存结构： 一体式结构：存储表信息的单元和元素存储区被安排在一块存储区里； 分离式结构：存储表信息的单元和元素存储区不被安排在一起，通过一个连接实现相连。 分离式结构扩容 替换元素存储区： 分离式结构的优势，可以在标识不变的情况下，为表对象换一块存储区。（可以改变表的容量）。 替换策略：容量加倍 每次更换存储区的时候，加倍容量:1,2,4,……。 这样算下来,总元素为n个时，时间复杂度为O（n），平均每个元素的时间复杂度为O（1）。 链接表 基本思想 表中的元素独立存储； 组成表结构的任一结点可以找到与其相关的下一结点； 前一节点中，用链接的方式显式地记录与下一结点之间的关联。 单链表 结点为二元组，表元素域中保存折作为表元素的数据项以及同一个表里下一个结点的标识。以下定义一个结点类 1234class LNode: def __init__(self,elem, next_ = None): self.elem = elem self.next = next_ 基本链表操作 创建空列表 删除链表 判断表是否为空 判断表是否满 加入元素 表首端插入： 123q = LNode(13)q.next = head.nexthead = q 一般情况的元素插入 创建新结点q并存入数据； 把pre所指结点next域的值存入新结点q的链接域next. 把pre结点的next域改为q 123q = LNode(15)q.next = pre.nextpre.next = q 删除元素 删除表首元素：更改表头指针，将其指向下一个结点即可。 1head = head.next 一般情况的元素删除：一般情况要先找到pre结点，将其next域指向被删结点的下一结点即可。 1pre.next = pre.next.next 扫描、定位和遍历 扫描 已知信息只有表头，故而只能从表头开始往下扫描： 1234p = headwhile p is not None and &lt;其他条件&gt;: &lt;对p进行操作&gt; p = p.next 后续为Python代码的实现，详细可以点击这里 两个链表的操作 链表翻转 python list类的reverse操作，可以实现两个元素互换。 *注意：如果使用单链表，则耗时会是O（n^2) 链表排序 python中的list对象有一个sort方法，可以实现排序。 单链表排序的实现过程。 从第1个元素开始循环，取出第i个元素。假设i前面的j个元素已经排好序了。 将i元素和j元素一一比较。如果第j个元素比i大，则将其右移一位； 直到找到比i小的元素为止，将i插入该空位。 以下为实现方法： 12345678def list_sort(lst): for i in range(1, len(lst)): #假设开始时[0:1]已经排序 x = lst[i] j = i while j &gt; 0 and lst[j-1] &gt; x: lst[j] = lst[j-1] j -= 1 lst[j] = x 单链表实现方法见笔记 总结 几种类型的表 基本单链表支持O（1）时间的前端插入&amp;删除工作；而定位和删除尾端都市O（n）时间 增加尾结点的单链表支持O（1）时间的首端/尾端插入和首端弹出，但不支持高效尾端删除; 循环单链表支持高效的首端/尾端插入和首端删除，但要注意结束条件； 双链表支持高效的首端/尾端删除和输入。 链接表的优点 表结构容易修改和调整 不需要修改结点的数据元素 方便管理（尽管python不需要管理） 链接表的缺点 定位访问需要线性时间 双链表在实现高效访问前后元素的时候，需要更多的存储空间。 存储一个表元素，就还需要存储一个链接域 表的应用 Josephus问题 代码依然见这里 第一种实现方法josephus_A由于需要遍历，算法复杂度很麻烦。这里暂时不细纠了。 第二种实现方法基于顺序表，见josephus_L，这种实现方式的复杂度为O（n^2） 第三种基于循环单链表，创建了一个Josephus类。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Python（一）-抽象数据结构]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Pyhon%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[抽象数据类型的概念 一个数据类型的操作通常可以分为三类： 构造操作：基于已知信息，产生同样类型的新对象； 解析操作：基于已知信息，产生不同类型的新对象； 变动操作：修改被操作对象的内部状态。 静态方法和类方法 静态方法：通过在类前添加修饰符@staticmethod实现，本质上为普通函数。它没有self参数； 类方法：以访问属性的形式调用，调用它的类将自动约束到方法的cls参数。可通过该参数方位该类的其他属性。 在编程过程中，__init__方法通常都用来检查参数的合法性，设置参数的数据属性。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（五）-类和对象]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（五）——CHAP6 类和对象 重点： 类的构造方法 类 类的声明 类体 类体中包含变量的声明以及类方法的定义。 类的构造方法 构造方法的名称和类名相同 没有返回类型，返回值，也不需要修饰符 虽然看起来和一般的成员方法没有区别，但不能被直接调用，只能被new运算符调用 构造方法不能被继承（因为它不是类的成员） 子类可以调用父类的构造方法 【举个栗子】 创建一个car类并调用。 1234567891011121314151617181920212223242526class Car&#123; private String Brand; int gas; Car (String vBrand, int vgas )&#123; //构造方法 Brand = vBrand; gas = vgas; &#125; void run()&#123; if (gas &gt; 0) gas -=10; else System.out.println("没油了，不能跑啦~"); &#125; void Disp()&#123; System.out.println("品牌："+Brand+"油量"+gas); &#125;&#125;class Example6_1&#123; public static void main(String args[])&#123; Car MyCar = new Car("Audi", 10); //创建对象mycar MyCar.Disp(); //调用disp方法 MyCar.run(); //调用run方法 System.out.println("car is running……"); MyCar.run(); &#125;&#125; 成员变量]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（四）-数组]]></title>
    <url>%2F2018%2F09%2F12%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（四）——CHAP5 数组 重点： java的高维数组每一个维数可以不一致 冒泡排序法 数组是用相同类型的元素组成的集合。这些元素可以是基本数据类型，也可以是构造出的数据类型。 包含以下几个部分： 数组名 数组类型 数组长度（有几个元素？） 数组中的元素是有顺序的。 一维数组 声明： int a[];或者int [] a;均可。 初始化： 直接在声明时初始化：int a[] = {1,2,3};，可用于元素较少的时候。 但是不能先声明再使用静态的初始化: 12int a[];a = &#123;1,2,3&#125;//会报错! 为数组分配内存空间，后续再赋值 12类型 数组名[];数组名 = new 类型[数组长度]； 例如： 12345int a = new int[4];a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; 【举个栗子】 实现冒泡升序排列 12345678910111213141516171819public class BubbleSort&#123; public static void main(String args[]) &#123; int i,j; int intArray[] = &#123;35,22,51,10,60&#125;; int len = intArray.length; for (i = 1; i &lt; len; i++) for (j = 0; j &lt; len - i - 1; j ++) if (intArray[j] &gt; intArray[j+1]) &#123; int t = intArray[j]; intArray[j] = intArray[j + 1]; intArray[j + 1] = t; &#125; System.out.println("the result after bubblesort: "); for (i = 0; i &lt; len - 1; i ++) System.out.println(intArray[i]); &#125; &#125; 把数组传递给方法 多维数组 二维数组的声明&amp;创建 声明： 12int a[][];double [][] b; 分配内存空间 直接为每一维分配空间： int a = new int[2][3];创建一个2*3维的数组； 从最高维开始分配：123int b = new int [2][];b[0] = new int[3];b[1] = new int[5]; 得到的形式如下： b[0][0] b[0][1] b[0][2] b[1][0] b[1][1] b[1][2] b[1][3] b[1][4] 注意 java数组的每一维不需要等长。 使用new分配内存时，至少需要给出最高维的大小。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（三）-程序流控制结构和方法]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E7%A8%8B%E5%BA%8F%E6%B5%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（三）——CHAP4 程序流控制结构和方法 重点： if elif条件嵌套 多选择结构switch+case 带标号的continue&amp;break 递归算法 switch语句 【举个栗子】switch + 三目条件运算（见笔记（一）） 本例可以把输入的字符串转换成数字： 以及在Java中，用双引号&quot;&quot;括起来的为String,用单引号’'括起来的是Char 12345678910111213141516171819202122232425262728293031import java.io.*;class SwitchTest2&#123; public static void main(String args[]) throws IOException &#123; char ch; System.out.print("enter a month: "); //这里是因为没有办法输入10,11,12这种两个字符的字节,故而用a,b,c代替 ch = (char)System.in.read(); &#123; System.in.skip(2); switch( (ch == '1'||ch == '2'||ch == 'c')?1: (ch == '3'||ch == '4'||ch == '5')?2: (ch == '6'||ch == '7'||ch == '8')?3: (ch == '9'||ch == 'a'||ch == 'b')?4:5) &#123; case 1: System.out.println("春季"); break; case 2: System.out.println("夏季"); break; case 3: System.out.println("秋季"); break; case 4: System.out.println("冬季"); break; default:System.out.println(ch + "是无效月份！"); &#125; System.out.print("switch语句出口！"); &#125; &#125;&#125; 结构化编程 for 循环 for(初值表达式1;循环条件表达式2;循环变量修改表达式3) 注定一定要确定循环条件，以防陷入死循环。 【举个栗子】计算1-100整数之和 123456789class LoopTest3&#123; public static void main(String args[])&#123; System.out.println("0-100 个整数之和 ：\n"); int i, sum = 0; for(i = 1; i &lt;= 100; i++) sum += i; System.out.println("sum=" + sum + ",i =" + i ); &#125;&#125; 另外，如果i是循环for里面定义的，则只在循环内有效。 【补充】用for循环实现和while一样的结构 123456int x = 10;for (;;;)&#123; if ( x &gt; 0) break; x -- ;&#125; 这时则需要和break结合。 嵌套循环和continue和break 带标识的continue 添加一个合法的JAVA标识符，并在其后面跟上冒号。 【举个栗子】 1234567891011121314151617181920import javax.swig.JOptionPane;public class ContinueLabTest&#123; public static void main(String args[]) &#123; String output = ""; rownext：//添加标识符 for (int row = 1; row &lt;= 5; row ++) &#123; output += "\n"; for(int column = 1; column &lt;= 10; column ++) &#123; if (column &gt; 2 * row - 1) continue rownext; //这里就是带标识的地方，跳出第二层for循环，回到外层的循环并判断循环条件。 output += "*"; &#125; &#125; JOptionPane.showMessageDialog(null, output, "testing continue with a label", JOptionPane.INFORMATION_MESSAGE); System.exit(0); &#125;&#125; break语句 break语句除了放在循环里，还能放在switch里。 break也可以带标号，常用在跳出多重循环里，只要在想跳出的循环前面加上break标号。 算法设计 这里先看一个基础的：递归 【举个栗子】用递归方法求阶乘LoopDGc 123456789101112131415class factor&#123; public long factorial(long n)&#123; if (n == 1) return 1 else return n * factor(n-1) &#125;&#125; public class LoopDGc &#123; public static void main (String args[]) &#123; long n = 20l; factor a = new factor(); long result = a.factorial(n); System.out.println(" "+n+" 的阶乘为" + result); &#125;&#125; 实际上这个地方还没怎么明白，尤其是主类和普通类。 首要还是要明白递归是什么东西……]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（二）-输入和输出]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（二）——CHAP3 Java的输入和输出 重点： System.out.write() 流式交互(InputStreamReader + BufferedReader) 标准输入/输出方法 Java里System包提供输入/输出流。 输出方法 println()输出后换行； print()输出后不换行； write()则被用来输出字节数组 以下举例： void println(char[] X)输出一个字符数组 void write(int b [])输出字节数组中的某一个元素，其后不换行。 123456789class PrintDemo&#123; public static void main(Strng args[])&#123; byte b[] = &#123;'f','g','h','i'&#125;; System.out.write(b,0,2); System.out.println(); //因为write后不换行，所以这里用println换行 System.out.write(b[0]); &#125;&#125; 输出结果是：fg和f 标准输入方法 用System.in.read()方法，有以下三种格式： 123public abstract in read() //从键盘输入一个字符public int read(byte[] b) //一次输入多个字节，并存在字节数组b中public int read (byte[] b, int off, int len)//限定输入的字节 另外，因为键盘输入很容易出错，所以必须引入异常处理机制。引入格式有两种 在main方法后直接用throws java.io.IOException子句抛出异常； 先在程序开头import java.io.*;加载语句,接着在main方法后加上throws IOExcrption子句来跑出异常。 【举个栗子】在键盘上一次输入多个字符并显示： 12345678910public class ReadCharDemo&#123; public static void main(String args[]) throws java.io.IOException &#123; byte b[] = new byte[16]; //定义长度为16的数组 System.out.println("\n 从键盘输出不超过16个字符，按回车键结束") System.in.read(b); System.out.printlb("\n 从键盘输入的是：") System.out.write(b,0,16);//用write直接输出字节数组。 &#125;&#125; 注意 如果用的是print方法，则需要把每一个元素都转化成字符，比较麻烦。 使用read方法时，还可以用read(b, 0, 10)来限制读入长度。（见上面提到的方法3） 利用命令行传入参数 123456public class HelloArgs&#123; public static void main(String args[]) &#123; System.out.println(args[0] + args[1] + "Hello!"); &#125;&#125; 接着可以在命令行里直接传递参数： 12E:\code\java-learning&gt; java HelloArgs 王可 王小可王可王小可Hello! 流式交互 1234567891011import java.io.*;public class HelloA1&#123; public static void main(String [] args) throws IOException &#123; InputStreamReader reader = new InputStreamReader(System.in); BufferedReader input = new BufferedReader(reader); System.out.print("Enter your name:"); String name = input.readLine(); System.out.println("Hello," + name + "!"); &#125; 这里reader作为InputStreamReader的一个实例存在，并且用作输入的System.in对象与之绑定； 接下在input作为BufferedReader的一个实例，与reader绑定； 用input的readLine方法来从键盘读取一整行的文字即可。 图形界面&amp;自定义类 以后再填坑，目前用不上，跳过。]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown必要语法补充]]></title>
    <url>%2F2018%2F09%2F11%2FMarkDown%E5%BF%85%E8%A6%81%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[编号： 使用数字+.+半角空格 代码块高亮 插入数学公式。 可以使用MathJax引擎。如果要用hexo进行部署，且使用的是next主题，则可直接在站点配置文件中更改： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 把enable改为true。 另外，安装hexo-math插件,可以实现MathJax的自动部署： 1npm install hexo-math --save 感受一下： x1+x2=x3x_1 + x_2 = x^3 x​1​​+x​2​​=x​3​​ 编写语法和tex语法一致。]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记（一）-语言基础]]></title>
    <url>%2F2018%2F09%2F11%2FJAVA%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[《JAVA程序设计教程》笔记（一）——CHAP2 JAVA语言基础 重点：最终变量、三元条件运算、位运算、MATH类 TIPS 注释格式 //表示单行注释 多行注释以/*开始，*/结尾 编程习惯 所有语句以分号结尾； Java区分大小写； 类名称以大写字母开头，变量以小写字母开头； 驼峰命名法； 文件名需要和public类在拼写和大小写上一致； JAVA语言基础 基本构成 标识符 所有标识符必须以A~Za~z，_或者$开头；（尤其注意不能以数字开头）； 流行的命名方式 常值标识符——全部大写： RED 类名标识符——大写字母开头+驼峰：MyCar 公有方法/实例变量——小写开头+驼峰：getCurrentValue 关键字 for while boolean …… 分隔符 注释 空白符（回车、TAB、换行），会被忽略 普通分隔符（{} ; , :） 直接量 运算符 数据类型 基本数据类型 整型：byte, short, int, long; 浮点型：float, double, 字符型：char 布尔型：boolean 直接量 程序中使用的常量 整数、浮点数、布尔值、字符、字符串 变量 一般变量要经历以下几个步骤 声明变量 变量的作用域和生命周期 最终变量 这个概念第一次听说。高亮~ 它指的是在运行过程中值不变的量，有点类似于常量。 定义的方法有两种。 直接定义： final double PI = 3.1415； 在声明的变量前加关键字，必要时再初始化： 123final double PI;……PI = 3.14159； 变量类型的转换 自动转换：两个类型兼容/目标类型大于原类型（比如byte转double) 强制转换 运算符&amp;表达式 只有一点要注意： 1234int i = 10;int j = 10;x = i ++;y = ++ j; x的值为10， y的值为11。所以++的位置要注意 逻辑运算符： !逻辑非 &amp;&amp;逻辑和 ||逻辑或 三元条件运算符 exp1&gt;exp2:exp3 例如： 12x = 10;y = x &gt; 9 ? 100:200 输出y为100，否则y为200 MATH类的操作 Math在JAVA.lang类包里。 调用e和PI:Math.E Math.PI 最大最小化：Math.max(val,val) Math.min(val,val) 绝对值: Math.abs() 四舍五入： Math.round() Math.rint() Math.ceil() Math.floor() 幂和对数:exp(),pow(),log() 三角函数：Math.sin()等]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java10的环境配置]]></title>
    <url>%2F2018%2F09%2F10%2Fjava10%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[好久没碰JAVA，今天重新下了个JDK10，发现配置较之前学习的有所变化。主要是PATH和JRE的环境配置： CLASSPATH配置 首先在环境变量中添加JAVA_HOME为jdk的安装路径； 新建一个CLASSPATH的系统变量，并添加.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 注意前面不要忘记加点和分号。 PATH配置 直接用绝对路径，添加&lt;PATH_TO_JDK\bin&gt; （并不需要把jre也加进去） 验证安装是否成功 老三样，打开cmd，依次输入： 123java -versionjavacjava 都成功就说明装完啦~]]></content>
      <categories>
        <category>CS之路</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github博客搭建]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[刚开学没事干，所以想着来搭个博客吧。也是为了激励自己能够养成及时总结的习惯。 hexo+github的博客搭建教程网络上很多，我主要搜了知乎的这一篇，讲得很详细：GitHub+Hexo 搭建个人网站详细教程 此外这个作者的汇总做的也不错：Hexo+GithubPages&amp;CodingPages搭建自己的个人博客 还有这个作者的汇总：我的个人博客之旅：从jekyll到hexo 设置多个tags以及categories 在写这个blog的时候还发现，如果直接在tags后面写多个tags会显示成一个，这是不行的。 这里提供了解决方法：hexo搭建博客–给文章添加多个tag或category 注意这里的categories是直接显示的侧边栏。 以下是一些常用个性化设置： 修改文本链接样式： 链接文本改为蓝色，鼠标划过时文字颜色加深： 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 1234567.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; &#125;&#125; 在侧边栏添加tags： 新建一个页面，命名为 tags： 1hexo new page tags 这会在blog的根目录的source下生成一个tags文件夹，文件夹里面带了一个index.md 点进去，修改： 12345---title: tagsdate: 2018-09-08 15:23:35type: &quot;tags&quot;--- 注意不要忘记在冒号之后打半角空格 增加搜索框 以下是网络上的方法，但是我尝试了一下没啥用= = 首先安装hexo-generator-searchdb插件(在blog的根目录下) 1npm install hexo-generator-searchdb --save 接着，找到站点配置的_config.yml文件，在任意位置添加： 12345search: path: search.xml field: post format: html limit: 10000 以下是next主题配置自带的功能： 在next的_config.yml文件夹下，找到“local_search”这一栏，把默认的false改为“auto&quot;(自动匹配)或者”manual&quot;(手动匹配)即可。 1234567local_search: enable: auto # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 控制预览字数/博文缩略显示 在想要断页的地方添加：&lt;!--more--&gt;，可以精确控制字数； 或者在next的_config.yml文件中，找到auto_excerpt项，然后把底下的false改为true。这样可以控制每篇blog都显示相同的字数。 markdown-it-plus 这个底下有不少插件 首先，卸载原有的渲染工具： 1234npm un hexo-renderer-marked --save#卸载旧的默认Markdown插件npm install hexo-renderer--markdown-it-plus --save#安装新的增强型插件 插入数学公式 使用katex，首先，需要安装katex支持插件： 1npm install markdown-it-katex 接下来，在站点配置文件中，把markdown-it-plus自带的mark关闭，并开启katex： 12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false 配置完之后，还需要在网页中引入相关的CSS文件，如果不想每次都写的话，可以在next主题里themes\next\layout\_custom\header.swig文件中修改，写入如下内容： 这里我踩了个坑，markdown-it-katex官方给的最新的katex文件渲染的上下标有问题，改为下面这个版本后解决了。 12&lt;link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"&gt;# 不要引入最新的katex文件，显示效果和插件并不兼容 接着，安装自动渲染的插件：hexo-math 1npm install hexo-math 然后在站点配置文件中添加如下内容 1234567891011math: engine: &apos;katex&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 就可以啦。实现如下： a2+b2=c1a^2 + b ^ 2 = c_1 a​2​​+b​2​​=c​1​​ 设置脚标 markdown本身是自带脚标的，可以在正文里输入&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在文章末尾加上： 即可。 但是hexo并不支持这种渲染。好在markdown-it-plus里也可以设置。在安装了markdown-it-plus插件后，再安装其附属： 1npm install markdown-it-footnote 配置文件只需要写如下内容就可以： 123456789markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ 因为footnote这个插件是默认打开的。如果需要关闭的话，在markdown-it-plus的配置下再添加 1234plugins: - plugin: name: markdown-it-footnote enable: false 就可以。 next 背景的动态化设置。 背景设置在5.1版本之后方便了很多，在next主题配置文件里找到： 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: true# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 这几个是用来配置背景的，可以喜好选择true/false来开启和关闭这些动图。 添加头像 这个很简单，在next主题配置文件中，找到： 12# Sidebar Avataravatar: /images/avatar.jpg 把avatar前面的#去掉即可。头像图片放在next/source/images里。 使用gitment添加评论 我觉得gitment比较方便的是不用另外注册账号了~ 主要参考这篇的配置 利用七牛云作为图床。 七牛云图床插件 账号配置与使用：点这里 测试：]]></content>
      <categories>
        <category>日常瞎玩</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
